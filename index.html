<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Network-Opinion Co-evolution Model</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jstat/1.9.6/jstat.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@2.2.1/dist/chartjs-plugin-annotation.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <style>
    body {
      font-family: 'Inter', sans-serif;
      overscroll-behavior: none;
    }
    .chart-container {
      position: relative;
      height: 90px;
      width: 100%;
    }
    .tooltip {
      position: absolute;
      text-align: center;
      padding: 8px;
      font: 12px sans-serif;
      background: lightsteelblue;
      border-radius: 8px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
    }
    .collapsible-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease-out;
    }
    .collapsible-content.active {
      max-height: 2000px;
      transition: max-height 0.5s ease-in;
    }
    .math-section {
      font-size: 0.9rem;
      line-height: 1.6;
    }
    .math-section h4 {
      font-weight: 600;
      margin-top: 1rem;
      margin-bottom: 0.5rem;
    }
    .warning-banner {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }
  </style>
</head>
<body class="bg-gray-100 text-gray-800 antialiased">

<div class="container mx-auto p-4 max-w-7xl">
  <!-- Header -->
  <div class="text-center mb-4">
    <h1 class="text-3xl font-bold text-gray-900">Network-Opinion Co-evolution Model</h1>
    <p class="text-md text-gray-600 mb-2">An interactive simulation by Will Gao, Yash Meher, and Fred Pan.</p>
    
    <!-- Computational Warning -->
    <div class="warning-banner text-white p-3 rounded-lg mb-4 max-w-4xl mx-auto">
      <p class="text-sm font-medium">
        ‚ö†Ô∏è <strong>Computational Warning:</strong> This simulation runs entirely in your browser and can be computationally intensive. 
        Performance may vary based on your device's capabilities.
      </p>
    </div>
    
    <!-- Zealot Guidance -->
    <div class="bg-blue-50 border-l-4 border-blue-400 p-3 rounded max-w-4xl mx-auto">
      <p class="text-sm text-blue-800">
        <strong>üí° Tip:</strong> To ensure zealots appear (‚â•90% probability), set Growth Duration to at least:
        <span class="font-mono bg-blue-100 px-1 rounded">462</span> for r=0.01,
        <span class="font-mono bg-blue-100 px-1 rounded">95</span> for r=0.05, or
        <span class="font-mono bg-blue-100 px-1 rounded">49</span> for r=0.10
      </p>
    </div>
  </div>

  <!-- Main Layout -->
  <div class="flex flex-col lg:flex-row gap-4">
    <!-- Left Panel -->
    <div class="w-full lg:w-1/3 bg-white p-4 rounded-lg shadow-md flex flex-col gap-4 overflow-y-auto max-h-[calc(100vh-2rem)]">
      
      <!-- Model Details (Collapsible) -->
      <div>
        <button id="model-details-btn" class="w-full text-left bg-gray-50 hover:bg-gray-100 p-3 rounded-lg flex justify-between items-center">
          <h2 class="text-xl font-bold">üìä Model Details</h2>
          <span id="model-details-arrow" class="text-gray-500">‚ñº</span>
        </button>
        <div id="model-details-content" class="collapsible-content">
          <div class="math-section p-4 bg-gray-50 rounded-b-lg">
            <h4>State Space</h4>
            <p>The system evolves on \(\Omega = \bigcup_{N=1}^{\infty} \left(\mathcal{G}_N \times [0,1]^N\right)\), where \(\mathcal{G}_N\) denotes simple undirected graphs on \(N\) vertices.</p>
            
            <h4>Initialization</h4>
            <p>‚Ä¢ Network: Complete graph \(K_4\)<br/>
            ‚Ä¢ Opinions: \(w_i(0) \sim \text{Beta}(2,2)\)</p>
            
            <h4>Dynamics (per timestep)</h4>
            <p><strong>1. Newcomer Arrival (t ‚â§ T):</strong><br/>
            Add \(\max(1, \lfloor r \cdot |V_t| \rfloor)\) agents. With probability 0.005, introduce paired zealots with fixed opinions {0,1}.</p>
            
            <p><strong>2. Friend Recommendation:</strong><br/>
            Acceptance probability: \[p_{\text{accept}} = (1 - |w_i - w_j|) \cdot \frac{D_{\text{char}}}{D_{\text{char}} + d_i}\]
            where \(D_{\text{char}} = 25\)</p>
            
            <p><strong>3. Opinion Update:</strong><br/>
            \[w_i(t+1) = 0.5 \cdot w_i(t) + 0.5 \cdot \bar{w}_{\Gamma_i}(t)\]
            where \(\bar{w}_{\Gamma_i}\) is the weighted neighborhood mean (zealots have weight \(W_z\))</p>
            
            <p><strong>4. Unfriending:</strong><br/>
            Probability: \(p_{\text{unfriend}} = |w_i - w_j|\) for most distant neighbor</p>
            
            <p><strong>5. Rewiring:</strong><br/>
            With probability 0.05, replace random edge</p>
            
            <h4>Polarization Metrics</h4>
            <p><strong>Bimodality Coefficient:</strong> \(\text{BC} = \frac{g^2 + 1}{k + 3}\)<br/>
            (BC > 5/9 indicates bimodality)</p>
            
            <p><strong>Network Modularity:</strong> \(Q = \frac{1}{2m}\sum_{i,j}\left[A_{ij} - \frac{k_i k_j}{2m}\right]\delta(c_i, c_j)\)</p>
            
            <p><strong>Opinion Assortativity:</strong> Pearson correlation of opinions across edges</p>
            
            <p><strong>Esteban-Ray Index:</strong> \(\text{ER} = \sum_{k,l} p_k^{1+\alpha} p_l |w_k - w_l|\)<br/>
            (with \(\alpha = 1.0\))</p>
          </div>
        </div>
      </div>
      
      <!-- Controls -->
      <div>
        <h2 class="text-xl font-bold mb-3 border-b pb-2">Controls</h2>
        <div class="grid grid-cols-2 gap-2 mb-3">
          <button id="start-pause-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg">Start</button>
          <button id="reset-btn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg">Reset</button>
        </div>
        <div class="space-y-3">
          <div>
            <label class="block font-medium mb-1">Friend Recommendation:</label>
            <select id="recommendation-algo" class="w-full p-2 border rounded-lg bg-gray-50">
              <option value="homophily" selected>Homophily-based</option>
              <option value="random">Random FoF</option>
              <option value="popularity">Popularity-based</option>
              <option value="community">Community-based</option>
            </select>
          </div>
          <div>
            <label>Growth Rate (r): <span id="growth-rate-value" class="font-mono text-sm">0.10</span></label>
            <input type="range" id="growth-rate" min="0.01" max="0.30" step="0.01" value="0.10" class="w-full">
          </div>
          <div>
            <label>Growth Duration (T): <span id="growth-duration-value" class="font-mono text-sm">75</span></label>
            <input type="range" id="growth-duration" min="10" max="500" step="5" value="75" class="w-full">
          </div>
          <div>
            <label>Zealot Weight (W<sub>z</sub>): <span id="zealot-weight-value" class="font-mono text-sm">5.0</span></label>
            <input type="range" id="zealot-weight" min="1.0" max="20.0" step="0.5" value="5.0" class="w-full">
          </div>
        </div>
      </div>

      <!-- Live Stats -->
      <div>
        <h2 class="text-xl font-bold mb-3 border-b pb-2">Live Statistics</h2>
        <div class="grid grid-cols-2 gap-2 text-center">
          <div class="bg-gray-100 p-2 rounded-lg">
            <div class="text-sm text-gray-500">Time Step (t)</div>
            <div id="time-step" class="text-2xl font-bold">0</div>
          </div>
          <div class="bg-gray-100 p-2 rounded-lg">
            <div class="text-sm text-gray-500">Agents</div>
            <div id="agent-count" class="text-2xl font-bold">0</div>
          </div>
        </div>
        <div class="grid grid-cols-2 gap-2 text-center mt-2">
          <div class="bg-blue-50 p-2 rounded-lg">
            <div class="text-sm text-gray-500">Zealots (0)</div>
            <div id="zealot-0-count" class="text-xl font-bold text-blue-600">0</div>
          </div>
          <div class="bg-red-50 p-2 rounded-lg">
            <div class="text-sm text-gray-500">Zealots (1)</div>
            <div id="zealot-1-count" class="text-xl font-bold text-red-600">0</div>
          </div>
        </div>
      </div>

      <!-- Metrics -->
      <div>
        <h2 class="text-xl font-bold mb-3 border-b pb-2">Polarization Metrics</h2>
        <div class="grid grid-cols-2 gap-4">
          <div>
            <h3 class="font-semibold">Bimodality Coefficient <span id="bc-value" class="font-mono text-sm bg-gray-200 px-1 rounded">0.000</span></h3>
            <div class="chart-container"><canvas id="bc-chart"></canvas></div>
          </div>
          <div>
            <h3 class="font-semibold">Network Modularity (Q) <span id="mod-value" class="font-mono text-sm bg-gray-200 px-1 rounded">0.000</span></h3>
            <div class="chart-container"><canvas id="mod-chart"></canvas></div>
          </div>
          <div>
            <h3 class="font-semibold">Opinion Assortativity (r) <span id="assort-value" class="font-mono text-sm bg-gray-200 px-1 rounded">0.000</span></h3>
            <div class="chart-container"><canvas id="assort-chart"></canvas></div>
          </div>
          <div>
            <h3 class="font-semibold">Esteban-Ray Index <span id="er-value" class="font-mono text-sm bg-gray-200 px-1 rounded">0.000</span></h3>
            <div class="chart-container"><canvas id="er-chart"></canvas></div>
          </div>
        </div>
      </div>
    </div>

    <!-- Right Panel: Simulation -->
    <div class="w-full lg:w-2/3 bg-white rounded-lg shadow-md overflow-hidden">
      <svg id="simulation-svg" class="w-full h-[calc(100vh-2rem)]"></svg>
    </div>
  </div>
</div>

<div id="tooltip" class="tooltip"></div>

<script type="module">
  // =============================
  // MODEL PARAMETERS (from paper)
  // =============================
  const P_PAIRED_ZEALOT = 0.005;  // Probability of zealot pair arrival
  const P_REWIRE = 0.05;          // Exogenous rewiring probability
  const INITIAL_AGENTS = 4;       // Start with K_4 complete graph
  const CHARACTERISTIC_DEGREE = 25; // D_char for acceptance probability
  const OPINION_INERTIA = 0.5;    // Weight on own opinion in update

  // Dynamic parameters from UI
  function getGrowthRate() { return parseFloat(document.getElementById('growth-rate').value); }
  function getGrowthDuration() { return parseInt(document.getElementById('growth-duration').value); }
  function getZealotWeight() { return parseFloat(document.getElementById('zealot-weight').value); }

  let nodes = [], links = [], timeStep = 0, isRunning = false, simulationInterval, nextNodeId = 0;

  // ---- D3 Setup ----
  const svg = d3.select("#simulation-svg");
  const zoomLayer = svg.append("g");
  const tooltip = d3.select("#tooltip");

  svg.call(
    d3.zoom().scaleExtent([0.1, 4]).on("zoom", (event) => {
      zoomLayer.attr("transform", event.transform);
    })
  );

  const linkGroup = zoomLayer.append("g").attr("class", "links");
  const nodeGroup = zoomLayer.append("g").attr("class", "nodes");

  const width = svg.node().getBoundingClientRect().width;
  const height = svg.node().getBoundingClientRect().height;
  const colorScale = d3.scaleSequential(d3.interpolateCool).domain([0, 1]);

  const simulation = d3.forceSimulation(nodes)
    .force("link", d3.forceLink(links).id(d => d.id).distance(50).strength(0.1))
    .force("charge", d3.forceManyBody().strength(-150))
    .force("center", d3.forceCenter(width / 2, height / 2))
    .on("tick", ticked);

  let link, node;

  // ---- Chart setup ----
  const chartConfigs = {
    bc: { label: 'Bimodality Coefficient', data: [], line: 0.555 },
    mod: { label: 'Network Modularity (Q)', data: [] },
    assort: { label: 'Opinion Assortativity (r)', data: [] },
    er: { label: 'Esteban-Ray Index', data: [] }
  };
  const charts = {};
  Chart.register(window['chartjs-plugin-annotation']);
  function createChart(canvasId, config) {
    const ctx = document.getElementById(canvasId).getContext('2d');
    return new Chart(ctx, {
      type: 'line',
      data: { labels: [], datasets: [{ label: config.label, data: config.data, borderColor: 'rgba(59, 130, 246, 0.8)', backgroundColor: 'rgba(59, 130, 246, 0.1)', borderWidth: 2, pointRadius: 0, tension: 0.3, fill: true }] },
      options: {
        responsive: true, maintainAspectRatio: false,
        scales: { x: { display: false }, y: { suggestedMin: (canvasId === 'assort-chart') ? -1 : 0, suggestedMax: 1, ticks: { maxTicksLimit: 4 } } },
        plugins: { legend: { display: false }, annotation: config.line ? { annotations: { line1: { type: 'line', yMin: config.line, yMax: config.line, borderColor: 'red', borderWidth: 2, borderDash: [6, 6], label: { content: 'BC = 5/9', enabled: true, position: 'end' } } } } : {} }
      }
    });
  }

  // ---- Model logic ----
  function initializeModel() {
    timeStep = 0; nextNodeId = 0; nodes.length = 0; links.length = 0;
    // Initialize with K_4 (complete graph on 4 vertices)
    for (let i = 0; i < INITIAL_AGENTS; i++) nodes.push(createAgent());
    for (let i = 0; i < INITIAL_AGENTS; i++) for (let j = i + 1; j < INITIAL_AGENTS; j++) links.push({ source: nodes[i].id, target: nodes[j].id });
    for (const key in charts) { charts[key].data.labels = []; charts[key].data.datasets[0].data = []; charts[key].update(); }
    updateDisplays(); updateSimulation();
  }
  
  function createAgent(isZealot = false, fixedOpinion = null) {
    const agent = { id: nextNodeId++, opinion: jStat.beta.sample(2, 2), isZealot: isZealot };
    if (isZealot) agent.opinion = (fixedOpinion !== null) ? fixedOpinion : (Math.random() < 0.5 ? 0 : 1);
    return agent;
  }
  
  function linkExists(a, b) { 
    return links.some(l => { 
      const s = l.source.id ?? l.source; 
      const t = l.target.id ?? l.target; 
      return (s === a && t === b) || (s === b && t === a); 
    }); 
  }

  function findClosestAgent(agent, candidates) {
    return candidates.reduce((closest, cand) => {
        const diff = Math.abs(agent.opinion - cand.opinion);
        return diff < Math.abs(agent.opinion - closest.opinion) ? cand : closest;
    }, candidates[0]);
  }

  function simulationStep() {
    if (nodes.length === 0) return;
    timeStep++;

    // ===================================
    // PHASE 1: NEWCOMER ARRIVAL (t ‚â§ T)
    // ===================================
    if (timeStep <= getGrowthDuration()) {
        const numNewAgents = Math.max(1, Math.floor(nodes.length * getGrowthRate()));
        const existingAgents = nodes.slice();
        const nonZealotTargets = existingAgents.filter(a => !a.isZealot);

        let agentsToAdd = 0;
        while (agentsToAdd < numNewAgents) {
            const isZealotArrival = Math.random() < P_PAIRED_ZEALOT;
            if (isZealotArrival && nonZealotTargets.length > 0) {
                // Paired Zealot Arrival
                const zealot1 = createAgent(true, 0);
                const zealot2 = createAgent(true, 1);
                
                let target1 = findClosestAgent(zealot1, nonZealotTargets);
                nodes.push(zealot1);
                if(target1 && !linkExists(zealot1.id, target1.id)) {
                    links.push({ source: zealot1.id, target: target1.id });
                }

                let target2 = findClosestAgent(zealot2, nonZealotTargets);
                nodes.push(zealot2);
                if(target2 && !linkExists(zealot2.id, target2.id)) {
                    links.push({ source: zealot2.id, target: target2.id });
                }
                
                agentsToAdd += 2;
            } else {
                // Regular Agent Arrival
                const newcomer = createAgent(false);
                nodes.push(newcomer);
                if (existingAgents.length > 0) {
                    const targetAgent = existingAgents[Math.floor(Math.random() * existingAgents.length)];
                    if (!linkExists(newcomer.id, targetAgent.id)) {
                        links.push({ source: newcomer.id, target: targetAgent.id });
                    }
                }
                agentsToAdd++;
            }
        }
    }

    // ================================================
    // PHASE 2: FRIEND RECOMMENDATION & EDGE FORMATION
    // ================================================
    const recommendationAlgo = document.getElementById('recommendation-algo').value;
    const newLinks = [];
    const adj = getAdjacencyList();

    nodes.forEach(agent => {
        const neighbors = new Set(adj[agent.id] || []);
        neighbors.add(agent.id);

        let recommendedAgent = null;
        const friendsOfFriends = getFriendsOfFriends(agent.id, adj);

        if (friendsOfFriends.length > 0) {
            let candidates = [];
            if (recommendationAlgo === 'random') {
                candidates = friendsOfFriends;
            } else if (recommendationAlgo === 'popularity') {
                let maxDegree = -1;
                friendsOfFriends.forEach(fof => {
                    const degree = (adj[fof.id] || []).length;
                    if(degree > maxDegree) {
                        maxDegree = degree;
                        candidates = [fof];
                    } else if (degree === maxDegree) {
                        candidates.push(fof);
                    }
                });
            } else if (recommendationAlgo === 'homophily') {
                let minDiff = Infinity;
                friendsOfFriends.forEach(fof => {
                    const diff = Math.abs(fof.opinion - agent.opinion);
                    if(diff < minDiff){
                        minDiff = diff;
                        candidates = [fof];
                    } else if (diff === minDiff) {
                        candidates.push(fof);
                    }
                });
            } else if (recommendationAlgo === 'community') {
                 let maxMutual = -1;
                 friendsOfFriends.forEach(fof => {
                    const mutualCount = getMutualFriends(agent.id, fof.id, adj).length;
                    if(mutualCount > maxMutual){
                        maxMutual = mutualCount;
                        candidates = [fof];
                    } else if (mutualCount === maxMutual) {
                        candidates.push(fof);
                    }
                 });
            }
            if(candidates.length > 0) {
                recommendedAgent = candidates[Math.floor(Math.random() * candidates.length)];
            }
        } else { // No friends-of-friends, recommend random non-neighbor
            const nonNeighbors = nodes.filter(n => !neighbors.has(n.id));
            if (nonNeighbors.length > 0) {
                recommendedAgent = nonNeighbors[Math.floor(Math.random() * nonNeighbors.length)];
            }
        }

        if (recommendedAgent) {
            let acceptProb;
            if (agent.isZealot) {
                acceptProb = 1.0;
            } else {
                const degree = (adj[agent.id] || []).length;
                const opinionDiff = Math.abs(agent.opinion - recommendedAgent.opinion);
                const homophilyFactor = 1 - opinionDiff;
                const degreeDecay = CHARACTERISTIC_DEGREE / (CHARACTERISTIC_DEGREE + degree);
                acceptProb = homophilyFactor * degreeDecay;
            }

            if (Math.random() < acceptProb) {
                if (!linkExists(agent.id, recommendedAgent.id)) {
                    newLinks.push({ source: agent.id, target: recommendedAgent.id });
                }
            }
        }
    });
    links.push(...newLinks);

    // ======================================
    // PHASE 3: OPINION UPDATE (with Zealot Weight)
    // ======================================
    const nextOpinions = new Map();
    const currentAdj = getAdjacencyList();
    nodes.forEach(agent => {
        if (agent.isZealot) {
            nextOpinions.set(agent.id, agent.opinion);
            return;
        }
        const neighborIds = currentAdj[agent.id] || [];
        if (neighborIds.length === 0) {
            nextOpinions.set(agent.id, agent.opinion);
        } else {
            let weightedSumOfOpinions = 0;
            let sumOfWeights = 0;
            neighborIds.forEach(nid => {
                const neighbor = nodes.find(n => n.id === nid);
                if (neighbor) {
                    const weight = neighbor.isZealot ? getZealotWeight() : 1;
                    weightedSumOfOpinions += neighbor.opinion * weight;
                    sumOfWeights += weight;
                }
            });

            const weightedAvgNeighborOpinion = sumOfWeights > 0 ? weightedSumOfOpinions / sumOfWeights : 0;
            const newOpinion = OPINION_INERTIA * agent.opinion + (1 - OPINION_INERTIA) * weightedAvgNeighborOpinion;
            nextOpinions.set(agent.id, Math.max(0, Math.min(1, newOpinion))); // Clamp to [0,1]
        }
    });
    nodes.forEach(agent => agent.opinion = nextOpinions.get(agent.id));

    // ====================
    // PHASE 4: UNFRIENDING
    // ====================
    const linksToRemove = new Set();
    nodes.forEach(agent => {
        if (agent.isZealot) return;
        const currentNeighbors = (currentAdj[agent.id] || []).map(nid => nodes.find(n => n.id === nid)).filter(Boolean);
        if (currentNeighbors.length > 0) {
            let mostDistantFriend = null;
            let maxDist = -1;
            currentNeighbors.forEach(neighbor => {
                const dist = Math.abs(agent.opinion - neighbor.opinion);
                if (dist > maxDist) {
                    maxDist = dist;
                    mostDistantFriend = neighbor;
                }
            });
            
            if (mostDistantFriend) {
                const unfriendProb = maxDist; // Probability is the opinion difference
                if (Math.random() < unfriendProb) {
                     const linkIndex = links.findIndex(l => {
                        const sId = l.source.id ?? l.source;
                        const tId = l.target.id ?? l.target;
                        return (sId === agent.id && tId === mostDistantFriend.id) || 
                               (sId === mostDistantFriend.id && tId === agent.id);
                     });
                     if (linkIndex !== -1) {
                        linksToRemove.add(linkIndex);
                     }
                }
            }
        }
    });
    
    if (linksToRemove.size > 0) {
        links = links.filter((_, i) => !linksToRemove.has(i));
    }

    // ============================
    // PHASE 5: EXOGENOUS REWIRING
    // ============================
    const finalAdj = getAdjacencyList();
    const rewiringLinksToAdd = [];
    const rewiringLinksToRemove = new Set();

    nodes.forEach(agent => {
        if (Math.random() < P_REWIRE) {
            const agentNeighbors = finalAdj[agent.id] || [];
            if (agentNeighbors.length > 0) {
                const neighborToDropId = agentNeighbors[Math.floor(Math.random() * agentNeighbors.length)];
                const linkIndex = links.findIndex(l => {
                    const sId = l.source.id ?? l.source;
                    const tId = l.target.id ?? l.target;
                    return (sId === agent.id && tId === neighborToDropId) || 
                           (sId === neighborToDropId && tId === agent.id);
                });
                if(linkIndex !== -1) rewiringLinksToRemove.add(linkIndex);

                const neighborSet = new Set(agentNeighbors);
                neighborSet.add(agent.id);
                const nonNeighbors = nodes.filter(n => !neighborSet.has(n.id));
                if (nonNeighbors.length > 0) {
                    const newFriend = nonNeighbors[Math.floor(Math.random() * nonNeighbors.length)];
                    rewiringLinksToAdd.push({ source: agent.id, target: newFriend.id });
                }
            }
        }
    });

    if (rewiringLinksToRemove.size > 0) {
        links = links.filter((_, i) => !rewiringLinksToRemove.has(i));
    }
    links.push(...rewiringLinksToAdd);

    calculateAndDisplayMetrics();
    updateDisplays();
    updateSimulation();
  }

  function calculateAndDisplayMetrics() {
    if (nodes.length < 3 || links.length === 0) return;
    const opinions = nodes.map(n => n.opinion);

    // 1. Bimodality Coefficient (BC = (g^2 + 1) / (k + 3))
    const n = opinions.length;
    if (n > 3) {
        const mean = jStat.mean(opinions);
        const variance = jStat.variance(opinions, true);
        const stdDev = Math.sqrt(variance);
        
        if(stdDev > 0) {
            const skewness = jStat.skewness(opinions);
            const kurtosis = jStat.kurtosis(opinions);
            // Correct bimodality coefficient formula
            const bc = (Math.pow(skewness, 2) + 1) / (kurtosis + 3 * Math.pow(n - 1, 2) / ((n - 2) * (n - 3)));
            updateMetric('bc', bc);
        } else {
            updateMetric('bc', 0);
        }
    } else {
        updateMetric('bc', 0);
    }

    // 2. Network Modularity (Q)
    const { modularity } = calculateModularity(nodes, links);
    updateMetric('mod', modularity);

    // 3. Opinion Assortativity (r)
    const assortativity = calculateAssortativity(nodes, links);
    updateMetric('assort', assortativity);

    // 4. Esteban-Ray Index (using network communities)
    try {
        const { community } = calculateModularity(nodes, links);
        
        // Group nodes by their network community
        const communities = {};
        Object.entries(community).forEach(([nodeIdStr, commId]) => {
            const nodeId = parseInt(nodeIdStr);
            const node = nodes.find(n => n.id === nodeId);
            if (node) {
                if (!communities[commId]) communities[commId] = [];
                communities[commId].push(node);
            }
        });
        
        const communitySizes = Object.values(communities).map(comm => comm.length).sort((a,b) => b-a);
        
        // Use two largest communities for ER calculation
        if (communitySizes.length >= 2 && communitySizes[0] > 0 && communitySizes[1] > 0) {
            const sortedCommunities = Object.values(communities).sort((a,b) => b.length - a.length);
            const comm1 = sortedCommunities[0];
            const comm2 = sortedCommunities[1];
            
            const p1 = comm1.length / n;
            const p2 = comm2.length / n;
            const w1 = d3.mean(comm1.map(node => node.opinion));
            const w2 = d3.mean(comm2.map(node => node.opinion));
            
            if (isFinite(w1) && isFinite(w2)) {
                const alpha = 1.0;
                const er = Math.pow(p1, 1 + alpha) * p2 * Math.abs(w1 - w2) + 
                           Math.pow(p2, 1 + alpha) * p1 * Math.abs(w2 - w1);
                updateMetric('er', er);
            } else {
                updateMetric('er', 0);
            }
        } else {
            updateMetric('er', 0);
        }
    } catch (e) {
        console.warn("Community-based ER calculation failed:", e);
        updateMetric('er', 0);
    }
  }

  // --- Helper Functions ---
  function getAdjacencyList() {
    const adj = {};
    links.forEach(link => {
        const sourceId = link.source.id ?? link.source;
        const targetId = link.target.id ?? link.target;
        if (!adj[sourceId]) adj[sourceId] = [];
        if (!adj[targetId]) adj[targetId] = [];
        adj[sourceId].push(targetId);
        adj[targetId].push(sourceId);
    });
    return adj;
  }

  function getFriendsOfFriends(agentId, adj) {
    const friends = new Set(adj[agentId] || []);
    const fofs = new Set();
    friends.forEach(friendId => {
        (adj[friendId] || []).forEach(fofId => {
            if (fofId !== agentId && !friends.has(fofId)) {
                fofs.add(fofId);
            }
        });
    });
    return Array.from(fofs).map(id => nodes.find(n => n.id === id)).filter(Boolean);
  }

  function getMutualFriends(agent1Id, agent2Id, adj) {
    const friends1 = new Set(adj[agent1Id] || []);
    const friends2 = new Set(adj[agent2Id] || []);
    return [...friends1].filter(id => friends2.has(id));
  }
  
  function calculateModularity(nodes, links) {
    const nodeIds = nodes.map(n => n.id.toString());
    const edgeList = links.map(l => ({
        source: (l.source.id ?? l.source).toString(),
        target: (l.target.id ?? l.target).toString(),
        weight: 1
    }));

    if (nodeIds.length === 0 || edgeList.length === 0) {
        return { community: {}, modularity: 0 };
    }

    let community = {};
    nodeIds.forEach(id => community[id] = id);
    
    let m = edgeList.length;
    let adj = {};
    edgeList.forEach(edge => {
        if (!adj[edge.source]) adj[edge.source] = {};
        if (!adj[edge.target]) adj[edge.target] = {};
        adj[edge.source][edge.target] = 1;
        adj[edge.target][edge.source] = 1;
    });

    let degrees = {};
    nodeIds.forEach(id => {
        degrees[id] = 0;
        for(let neighbor in adj[id] || {}) {
            degrees[id] += adj[id][neighbor];
        }
    });

    // Simplified Louvain algorithm for community detection
    let improvement = true;
    let iterations = 0;
    while(improvement && iterations < 10) {
        improvement = false;
        iterations++;
        
        nodeIds.forEach(nodeId => {
            let best_comm = community[nodeId];
            let max_mod_gain = 0;
            
            let neighbor_comms = new Set();
            if(adj[nodeId]) {
                for(let neighborId in adj[nodeId]) {
                    neighbor_comms.add(community[neighborId]);
                }
            }

            neighbor_comms.forEach(comm_id => {
                let k_i_in = 0;
                if(adj[nodeId]) {
                    for(let neighborId in adj[nodeId]) {
                        if(community[neighborId] === comm_id) {
                            k_i_in += 1;
                        }
                    }
                }
                let sigma_tot = 0;
                nodeIds.forEach(id => {
                    if(community[id] === comm_id) sigma_tot += degrees[id];
                });
                
                let mod_gain = k_i_in - (degrees[nodeId] * sigma_tot) / (2*m);
                if(mod_gain > max_mod_gain) {
                    max_mod_gain = mod_gain;
                    best_comm = comm_id;
                }
            });

            if(best_comm !== community[nodeId]) {
                community[nodeId] = best_comm;
                improvement = true;
            }
        });
    }

    // Calculate modularity Q = (1/2m) * Œ£[A_ij - k_i*k_j/2m] * Œ¥(c_i, c_j)
    let Q = 0;
    let final_comms = {};
    Object.entries(community).forEach(([nodeId, commId]) => {
        if(!final_comms[commId]) final_comms[commId] = [];
        final_comms[commId].push(nodeId);
    });

    for(let commId in final_comms) {
        let l_c = 0;
        let d_c = 0;
        final_comms[commId].forEach(node1 => {
            d_c += degrees[node1] || 0;
            final_comms[commId].forEach(node2 => {
                if(adj[node1] && adj[node1][node2]) {
                    l_c += 1;
                }
            });
        });
        l_c /= 2;
        Q += (l_c / m) - Math.pow(d_c / (2*m), 2);
    }

    return { community, modularity: Q };
  }

  function calculateAssortativity(nodes, links) {
    if (links.length < 2) return 0;
    const m = links.length;
    const nodeMap = new Map(nodes.map(node => [node.id, node]));

    let sum1 = 0, sum2 = 0, sum3 = 0;

    links.forEach(link => {
        const sourceNode = nodeMap.get(link.source.id ?? link.source);
        const targetNode = nodeMap.get(link.target.id ?? link.target);
        if (!sourceNode || !targetNode) return;

        const w_i = sourceNode.opinion;
        const w_j = targetNode.opinion;

        sum1 += w_i * w_j;
        sum2 += w_i + w_j;
        sum3 += w_i * w_i + w_j * w_j;
    });

    sum1 /= m;
    sum2 /= (2*m);
    sum3 /= (2*m);

    const numerator = sum1 - sum2 * sum2;
    const denominator = sum3 - sum2 * sum2;

    if (Math.abs(denominator) < 1e-10) return 0;
    return numerator / denominator;
  }

  function updateDisplays() {
    d3.select("#time-step").text(timeStep);
    d3.select("#agent-count").text(nodes.length);
    
    // Count zealots
    const zealot0Count = nodes.filter(n => n.isZealot && n.opinion === 0).length;
    const zealot1Count = nodes.filter(n => n.isZealot && n.opinion === 1).length;
    d3.select("#zealot-0-count").text(zealot0Count);
    d3.select("#zealot-1-count").text(zealot1Count);
  }
  
  function updateMetric(key, value) {
    if (!isFinite(value)) value = 0;
    d3.select(`#${key}-value`).text(value.toFixed(3));
    const chart = charts[key];
    if (chart.data.labels.length > 100) { 
      chart.data.labels.shift(); 
      chart.data.datasets[0].data.shift(); 
    }
    chart.data.labels.push(timeStep);
    chart.data.datasets[0].data.push(value);
    chart.update('none');
  }

  function updateSimulation() {
    node = nodeGroup.selectAll("circle").data(nodes, d => d.id);
    link = linkGroup.selectAll("line").data(links, d => `${d.source.id ?? d.source}-${d.target.id ?? d.target}`);
    node.exit().remove(); 
    link.exit().remove();
    
    const nodeEnter = node.enter().append("circle")
      .attr("r", d => d.isZealot ? 8 : 6)
      .attr("stroke", d => d.isZealot ? "#333" : "#fff")
      .attr("stroke-width", d => d.isZealot ? 2 : 1.5)
      .call(d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended))
      .on("mouseover", (event, d) => { 
        tooltip.transition().duration(200).style("opacity", .9); 
        tooltip.html(`ID: ${d.id}<br/>Opinion: ${d.opinion.toFixed(3)}<br/>${d.isZealot ? '<b>ZEALOT</b>' : ''}`)
          .style("left", (event.pageX + 5) + "px")
          .style("top", (event.pageY - 28) + "px"); 
      })
      .on("mouseout", () => tooltip.transition().duration(500).style("opacity", 0));
    
    node = nodeEnter.merge(node);
    node.transition().duration(300).attr("fill", d => colorScale(d.opinion));
    
    link = link.enter().append("line")
      .attr("stroke", "#999")
      .attr("stroke-opacity", 0.6)
      .merge(link);
    
    simulation.nodes(nodes); 
    simulation.force("link").links(links); 
    simulation.alpha(0.1).restart();
  }
  
  function ticked() {
    link.attr("x1", d => d.source.x).attr("y1", d => d.source.y)
        .attr("x2", d => d.target.x).attr("y2", d => d.target.y);
    node.attr("cx", d => d.x).attr("cy", d => d.y);
  }
  
  function dragstarted(event, d) { 
    if (!event.active) simulation.alphaTarget(0.3).restart(); 
    d.fx = d.x; d.fy = d.y; 
  }
  function dragged(event, d) { d.fx = event.x; d.fy = event.y; }
  function dragended(event, d) { 
    if (!event.active) simulation.alphaTarget(0); 
    d.fx = null; d.fy = null; 
  }

  // ---- Event listeners ----
  document.getElementById('growth-rate').addEventListener('input', e => {
    document.getElementById('growth-rate-value').textContent = parseFloat(e.target.value).toFixed(2);
  });
  document.getElementById('growth-duration').addEventListener('input', e => {
    document.getElementById('growth-duration-value').textContent = e.target.value;
  });
  document.getElementById('zealot-weight').addEventListener('input', e => {
    document.getElementById('zealot-weight-value').textContent = parseFloat(e.target.value).toFixed(1);
  });

  // Collapsible model details
  document.getElementById('model-details-btn').addEventListener('click', () => {
    const content = document.getElementById('model-details-content');
    const arrow = document.getElementById('model-details-arrow');
    content.classList.toggle('active');
    arrow.textContent = content.classList.contains('active') ? '‚ñ≤' : '‚ñº';
  });

  const startPauseBtn = document.getElementById('start-pause-btn');
  startPauseBtn.addEventListener('click', () => {
    isRunning = !isRunning;
    if (isRunning) {
        startPauseBtn.textContent = 'Pause';
        simulationInterval = setInterval(simulationStep, 500);
    } else {
        startPauseBtn.textContent = 'Start';
        clearInterval(simulationInterval);
    }
  });
  
  document.getElementById('reset-btn').addEventListener('click', () => {
    isRunning = false;
    clearInterval(simulationInterval);
    startPauseBtn.textContent = 'Start';
    initializeModel();
  });

  // ---- Initialize ----
  Object.keys(chartConfigs).forEach(key => { 
    charts[key] = createChart(`${key}-chart`, chartConfigs[key]); 
  });
  
  // Initialize MathJax
  window.MathJax = {
    tex: {
      inlineMath: [['\\(', '\\)']],
      displayMath: [['\\[', '\\]']]
    }
  };
  
  initializeModel();
</script>
</body>
</html>