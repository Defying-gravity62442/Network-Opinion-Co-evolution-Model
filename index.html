<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Network-Opinion Co-evolution Model ‚Äî Fixed</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jstat/1.9.6/jstat.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@2.2.1/dist/chartjs-plugin-annotation.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <style>
    body { font-family: 'Inter', sans-serif; overscroll-behavior: none; }
    .chart-container { position: relative; height: 90px; width: 100%; }
    .tooltip { position: absolute; text-align: left; padding: 8px; font: 12px sans-serif; background: rgba(0,0,0,0.75); color:#fff; border-radius: 6px; pointer-events: none; opacity: 0; transition: opacity .15s; }
    .warning-banner { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
    .collapsible-content { max-height: 0; overflow: hidden; transition: max-height 0.3s ease-out; }
    .collapsible-content.active { max-height: 2000px; transition: max-height 0.5s ease-in; }
    .math-section { font-size: 0.9rem; line-height: 1.6; }
    .math-section h4 { font-weight: 600; margin-top: 1rem; margin-bottom: 0.5rem; }
  </style>
</head>
<body class="bg-gray-100 text-gray-800 antialiased">

<div class="container mx-auto p-4 max-w-7xl">
  <!-- Header -->
  <div class="text-center mb-4">
    <h1 class="text-3xl font-bold text-gray-900">Network-Opinion Co-evolution Model</h1>
    <p class="text-md text-gray-600 mb-2">An interactive simulation by Will Gao, Yash Meher, and Fred Pan.</p>
    <!-- Computational Warning -->
    <div class="warning-banner text-white p-3 rounded-lg mb-4 max-w-4xl mx-auto">
      <p class="text-sm font-medium">
        ‚ö†Ô∏è <strong>Computational Warning:</strong> This simulation runs entirely in your browser and can be computationally intensive.
        Performance may vary based on your device's capabilities.
      </p>
    </div>

    <div class="bg-blue-50 border-l-4 border-blue-400 p-3 rounded max-w-4xl mx-auto mb-4">
      <p class="text-sm text-blue-800">
        <strong>üí° Tip:</strong> To ensure zealots appear (‚â•90% probability), set Growth Duration to at least:
        <span class="font-mono bg-blue-100 px-1 rounded">462</span> for r=0.01,
        <span class="font-mono bg-blue-100 px-1 rounded">95</span> for r=0.05, or
        <span class="font-mono bg-blue-100 px-1 rounded">49</span> for r=0.10
      </p>
    </div>
       
    <div class="text-sm text-gray-500 max-w-2xl mx-auto bg-gray-50 p-3 rounded-lg border">
      <strong>Abstract:</strong> We present a discrete-time, agent-based Markov model capturing the coupled dynamics of a social network's topology and the continuous opinions of its agents...
    </div>
  </div>

  <div class="flex flex-col lg:flex-row gap-4">
    <div class="w-full lg:w-1/3 bg-white p-4 rounded-lg shadow-md flex flex-col gap-4 overflow-y-auto max-h-[calc(100vh-2rem)]">

      <!-- Model Details (Collapsible) -->
      <div>
          <button id="model-details-btn" class="w-full text-left bg-gray-50 hover:bg-gray-100 p-3 rounded-lg flex justify-between items-center">
          <h2 class="text-xl font-bold">üìä Model Details</h2>
          <span id="model-details-arrow" class="text-gray-500">‚ñº</span>
        </button>
        <div id="model-details-content" class="collapsible-content">
          <div class="math-section p-4 bg-gray-50 rounded-b-lg">
            <h4>State Space</h4>
            <p>The system evolves on \(\Omega = \bigcup_{N=1}^{\infty} \left(\mathcal{G}_N \times [0,1]^N\right)\), where \(\mathcal{G}_N\) denotes simple undirected graphs on \(N\) vertices.</p>
            
            <h4>Initialization</h4>
            <p>‚Ä¢ Network: Complete graph \(K_4\)<br/>
            ‚Ä¢ Opinions: \(w_i(0) \sim \text{Beta}(2,2)\)</p>
            
            <h4>Dynamics (per timestep)</h4>
            <p><strong>1. Newcomer Arrival (t ‚â§ T):</strong><br/>
            Add \(\max(1, \lfloor r \cdot |V_t| \rfloor)\) agents. With probability 0.005, introduce paired zealots with fixed opinions {0,1}.</p>
            
            <p><strong>2. Friend Recommendation:</strong><br/>
            Acceptance probability: \[p_{\text{accept}} = (1 - |w_i - w_j|) \cdot \frac{D_{\text{char}}}{D_{\text{char}} + d_i}\]
            where \(D_{\text{char}} = 25\)</p>
            
            <p><strong>3. Opinion Update:</strong><br/>
            \[w_i(t+1) = 0.5 \cdot w_i(t) + 0.5 \cdot \bar{w}_{\Gamma_i}(t)\]
            where \(\bar{w}_{\Gamma_i}\) is the weighted neighborhood mean (zealots have weight \(W_z\))</p>
            
            <p><strong>4. Unfriending:</strong><br/>
            Probability: \(p_{\text{unfriend}} = |w_i - w_j|\) for most distant neighbor</p>
            
            <p><strong>5. Rewiring:</strong><br/>
            With probability 0.05, replace random edge</p>
            
            <h4>Polarization Metrics</h4>
            <p><strong>Bimodality Coefficient:</strong> \(\text{BC} = \frac{g^2 + 1}{k + 3}\)<br/>
            (BC > 5/9 indicates bimodality)</p>
            
            <p><strong>Network Modularity:</strong> \(Q = \frac{1}{2m}\sum_{i,j}\left[A_{ij} - \frac{k_i k_j}{2m}\right]\delta(c_i, c_j)\)</p>
            
            <p><strong>Opinion Assortativity:</strong> Pearson correlation of opinions across edges</p>
            
            <p><strong>Esteban-Ray Index:</strong> \(\text{ER} = \sum_{k,l} p_k^{1+\alpha} p_l |w_k - w_l|\)<br/>
            (with \(\alpha = 1.0\))</p>
          </div>
        </div>
      </div>
      <div>
        <h2 class="text-xl font-bold mb-3 border-b pb-2">Controls</h2>
        <div class="flex justify-center gap-2 mb-3">
          <button id="start-pause-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg">Start</button>
          <button id="reset-btn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg">Reset</button>
        </div>
        <div class="space-y-3">
          <div>
            <label class="block font-medium mb-1">Friend Recommendation:</label>
            <select id="recommendation-algo" class="w-full p-2 border rounded-lg bg-gray-50">
              <option value="homophily" selected>Homophily-based</option>
              <option value="random">Random FoF</option>
              <option value="popularity">Popularity-based</option>
              <option value="community">Community-based</option>
            </select>
          </div>
          <div>
            <label>Growth Rate (r): <span id="growth-rate-value" class="font-mono text-sm">0.10</span></label>
            <input type="range" id="growth-rate" min="0.01" max="0.30" step="0.01" value="0.10" class="w-full">
          </div>
          <div>
            <label>Growth Duration (T): <span id="growth-duration-value" class="font-mono text-sm">75</span></label>
            <input type="range" id="growth-duration" min="10" max="200" step="5" value="75" class="w-full">
          </div>
          <div>
            <label>Zealot Weight (W<sub>z</sub>): <span id="zealot-weight-value" class="font-mono text-sm">5.0</span></label>
            <input type="range" id="zealot-weight" min="1.0" max="20.0" step="0.5" value="5.0" class="w-full">
          </div>
        </div>
      </div>

      <div>
        <h2 class="text-xl font-bold mb-3 border-b pb-2">Live Statistics</h2>
        <div class="grid grid-cols-3 gap-2 text-center">
          <div class="bg-gray-100 p-2 rounded-lg">
            <div class="text-sm text-gray-500">Time Step (t)</div>
            <div id="time-step" class="text-2xl font-bold">0</div>
          </div>
          <div class="bg-gray-100 p-2 rounded-lg">
            <div class="text-sm text-gray-500">Agents</div>
            <div id="agent-count" class="text-2xl font-bold">0</div>
          </div>
          <div class="bg-gray-100 p-2 rounded-lg">
            <div class="text-sm text-gray-500">Zealots</div>
            <div id="zealot-count" class="text-2xl font-bold">0</div>
          </div>
        </div>
      </div>

      <div>
        <h2 class="text-xl font-bold mb-3 border-b pb-2">Polarization Metrics</h2>
        <div class="grid grid-cols-2 gap-4">
          <div>
            <h3 class="font-semibold">Bimodality Coefficient <span id="bc-value" class="font-mono text-sm bg-gray-200 px-1 rounded">0.000</span></h3>
            <div class="chart-container"><canvas id="bc-chart"></canvas></div>
          </div>
          <div>
            <h3 class="font-semibold">Network Modularity (Q) <span id="mod-value" class="font-mono text-sm bg-gray-200 px-1 rounded">0.000</span></h3>
            <div class="chart-container"><canvas id="mod-chart"></canvas></div>
          </div>
          <div>
            <h3 class="font-semibold">Opinion Assortativity (r) <span id="assort-value" class="font-mono text-sm bg-gray-200 px-1 rounded">0.000</span></h3>
            <div class="chart-container"><canvas id="assort-chart"></canvas></div>
          </div>
          <div>
            <h3 class="font-semibold">Average Pairwise Distance (APD) <span id="apd-value" class="font-mono text-sm bg-gray-200 px-1 rounded">0.000</span></h3>
            <div class="chart-container"><canvas id="apd-chart"></canvas></div>
          </div>
        </div>
      </div>
    </div>

    <div class="w-full lg:w-2/3 bg-white rounded-lg shadow-md overflow-hidden">
      <svg id="simulation-svg" class="w-full h-[calc(100vh-2rem)]"></svg>
    </div>
  </div>
</div>

<!-- Heat Map Panel -->
<div id="heatmap-panel" class="container mx-auto p-4 max-w-7xl hidden">
  <div class="w-full bg-white rounded-lg shadow-md p-4">
    <h2 class="text-xl font-bold mb-1">Opinion‚ÄìOpinion Link Density (Heat Map)</h2>
    <p class="text-sm text-gray-600 mb-3">
      Axes: opinion bins [0,1] √ó [0,1]; each cell color encodes the share of <em>all links</em> in that (bin<sub>x</sub>, bin<sub>y</sub>).
      Empty cells are light gray; density increases from light red to deep red.
    </p>
    <svg id="heatmap-svg" class="w-full" style="height: 420px;"></svg>
  </div>
</div>

<script type="module">
  // ===== Model constants =====
  const INITIAL_AGENTS = 4;
  function getGrowthRate() { return parseFloat(document.getElementById('growth-rate').value); }
  function getGrowthDuration() { return parseInt(document.getElementById('growth-duration').value); }
  function getZealotWeight() { return parseFloat(document.getElementById('zealot-weight').value); }

  // ===== State =====
  let nodes = [], links = [], timeStep = 0, isRunning = false, simulationInterval, nextNodeId = 0;

  // ===== SVG + groups (no zoom/pan) =====
  const svg = d3.select("#simulation-svg");
  const width = svg.node().getBoundingClientRect().width;
  const height = svg.node().getBoundingClientRect().height;

  const margin = {top: 20, right: 20, bottom: 40, left: 50};
  const innerWidth = width - margin.left - margin.right;
  const innerHeight = height - margin.top - margin.bottom;

  // Root drawing layer (no zoom)
  const rootG = svg.append("g");
  const linkGroup = rootG.append("g").attr("class", "links");
  const nodeGroup = rootG.append("g").attr("class", "nodes");

  // Scales & axes
  const xScale = d3.scaleLinear().domain([0,1]).range([margin.left, width - margin.right]);
  let yScale = d3.scaleLinear().domain([0,1]).range([height - margin.bottom, margin.top]);

  const xAxisG = svg.append("g").attr("transform", `translate(0,${height - margin.bottom})`);
  const yAxisG = svg.append("g").attr("transform", `translate(${margin.left},0)`);

  xAxisG.call(d3.axisBottom(xScale));
  yAxisG.call(d3.axisLeft(yScale).ticks(5).tickFormat(d3.format("d")));

  svg.append("text").attr("x", (margin.left + innerWidth/2)).attr("y", height - 8)
    .attr("text-anchor","middle").text("Opinion");
  svg.append("text").attr("transform","rotate(-90)")
    .attr("x", - (margin.top + innerHeight/2)).attr("y", 14)
    .attr("text-anchor","middle").text("Degree");

  // Color scale (0 -> light blue, 1 -> red)
  const colorScale = d3.scaleSequential(d3.interpolateRgb("#9ecae1","#de2d26")).domain([0,1]);

  // Tooltip (single instance)
  const tooltip = d3.select("body").append("div").attr("class","tooltip");

  // ===== Charts =====
  const chartConfigs = {
    bc: { label: 'Bimodality Coefficient', data: [], line: 0.555 },
    mod: { label: 'Network Modularity (Q)', data: [] },
    assort: { label: 'Opinion Assortativity (r)', data: [] },
    apd: { label: 'Average Pairwise Distance (APD)', data: [] }
  };
  const charts = {};
  Chart.register(window['chartjs-plugin-annotation']);
  function createChart(canvasId, config) {
    const ctx = document.getElementById(canvasId).getContext('2d');
    return new Chart(ctx, {
      type: 'line',
      data: { labels: [], datasets: [{ label: config.label, data: config.data, borderColor: 'rgba(59, 130, 246, 0.8)', backgroundColor: 'rgba(59, 130, 246, 0.1)', borderWidth: 2, pointRadius: 0, tension: 0.3, fill: true }] },
      options: {
        responsive: true, maintainAspectRatio: false,
        scales: { x: { display: false }, y: { suggestedMin: (canvasId === 'assort-chart') ? -1 : 0, suggestedMax: 1, ticks: { maxTicksLimit: 4 } } },
        plugins: { legend: { display: false }, annotation: config.line ? { annotations: { line1: { type: 'line', yMin: config.line, yMax: config.line, borderColor: 'red', borderWidth: 2, borderDash: [6, 6] } } } : {} }
      }
    });
  }

  // ===== Model init / helpers =====
  function initializeModel() {
    timeStep = 0; nextNodeId = 0; nodes.length = 0; links.length = 0;
    for (let i = 0; i < INITIAL_AGENTS; i++) nodes.push(createAgent());
    for (let i = 0; i < INITIAL_AGENTS; i++) for (let j = i + 1; j < INITIAL_AGENTS; j++) links.push({ source: nodes[i].id, target: nodes[j].id });
    for (const key in charts) { charts[key].data.labels = []; charts[key].data.datasets[0].data = []; charts[key].update(); }
    updateDisplays(); updateSimulation(); drawHeatmap();
  }
  function createAgent(isZealot = false, fixedOpinion = null) {
    const agent = { id: nextNodeId++, opinion: jStat.beta.sample(2, 2), isZealot: isZealot };
    if (isZealot) agent.opinion = (fixedOpinion !== null) ? fixedOpinion : (Math.random() < 0.5 ? 0 : 1);
    return agent;
  }
  function linkExists(a, b) { return links.some(l => { const s = l.source.id ?? l.source; const t = l.target.id ?? l.target; return (s === a && t === b) || (s === b && t === a); }); }

  function getAdjacencyList() {
    const adj = {};
    links.forEach(link => {
      const sourceId = link.source.id ?? link.source;
      const targetId = link.target.id ?? link.target;
      if (!adj[sourceId]) adj[sourceId] = [];
      if (!adj[targetId]) adj[targetId] = [];
      adj[sourceId].push(targetId);
      adj[targetId].push(sourceId);
    });
    return adj;
  }
  function getFriendsOfFriends(agentId, adj) {
    const friends = new Set(adj[agentId] || []);
    const fofs = new Set();
    friends.forEach(friendId => { (adj[friendId] || []).forEach(fofId => { if (fofId !== agentId && !friends.has(fofId)) fofs.add(fofId); }); });
    return Array.from(fofs).map(id => nodes.find(n => n.id === id)).filter(Boolean);
  }
  function getMutualFriends(agent1Id, agent2Id, adj) {
    const friends1 = new Set(adj[agent1Id] || []);
    const friends2 = new Set(adj[agent2Id] || []);
    return [...friends1].filter(id => friends2.has(id));
  }

  // ===== Positioning by opinion (x) and degree (y) =====
  function assignPositions() {
    const adj = getAdjacencyList();
    const maxDeg = d3.max(nodes, n => (adj[n.id] || []).length) || 0;
    const axisMax = Math.max(1, maxDeg);
    yScale.domain([0, axisMax]);

    // update axes with **integer** ticks
    xAxisG.call(d3.axisBottom(xScale));
    yAxisG.call(d3.axisLeft(yScale).ticks(axisMax).tickFormat(d3.format("d")));

    nodes.forEach(n => {
      const deg = (adj[n.id] || []).length;
      n.x = xScale(n.opinion);
      n.y = yScale(deg);
    });
  }

  // ===== Simulation step (discrete time, no d3-force) =====
  function simulationStep() {
    if (nodes.length === 0) return;
    timeStep++;

    // Growth
    if (timeStep <= getGrowthDuration()) {
      const numNewAgents = Math.max(1, Math.floor(nodes.length * getGrowthRate()));
      const existingAgents = nodes.slice();
      const nonZealotTargets = existingAgents.filter(a => !a.isZealot);
      let agentsToAdd = 0;
      while (agentsToAdd < numNewAgents) {
        const isZealotArrival = Math.random() < 0.01;
        if (isZealotArrival && nonZealotTargets.length > 0) {
          const zealot1 = createAgent(true, 0);
          const zealot2 = createAgent(true, 1);
          let target1 = findClosestAgent(zealot1, nonZealotTargets);
          nodes.push(zealot1);
          if(target1 && !linkExists(zealot1.id, target1.id)) links.push({ source: zealot1.id, target: target1.id });
          let target2 = findClosestAgent(zealot2, nonZealotTargets);
          nodes.push(zealot2);
          if(target2 && !linkExists(zealot2.id, target2.id)) links.push({ source: zealot2.id, target: target2.id });
          agentsToAdd += 2;
        } else {
          const newcomer = createAgent(false);
          nodes.push(newcomer);
          if (existingAgents.length > 0) {
            const targetAgent = existingAgents[Math.floor(Math.random() * existingAgents.length)];
            if (!linkExists(newcomer.id, targetAgent.id)) links.push({ source: newcomer.id, target: targetAgent.id });
          }
          agentsToAdd++;
        }
      }
    }

    // Recommendations / new links
    const recommendationAlgo = document.getElementById('recommendation-algo').value;
    const newLinks = [];
    const adj = getAdjacencyList();

    nodes.forEach(agent => {
      const neighbors = new Set(adj[agent.id] || []);
      neighbors.add(agent.id);

      let recommendedAgent = null;
      const friendsOfFriends = getFriendsOfFriends(agent.id, adj);

      if (friendsOfFriends.length > 0) {
        let candidates = [];
        if (recommendationAlgo === 'random') {
          candidates = friendsOfFriends;
        } else if (recommendationAlgo === 'popularity') {
          let maxDegree = -1;
          friendsOfFriends.forEach(fof => {
            const degree = (adj[fof.id] || []).length;
            if(degree > maxDegree) { maxDegree = degree; candidates = [fof]; }
            else if (degree === maxDegree) candidates.push(fof);
          });
        } else if (recommendationAlgo === 'homophily') {
          let minDiff = Infinity;
          friendsOfFriends.forEach(fof => {
            const diff = Math.abs(fof.opinion - agent.opinion);
            if(diff < minDiff){ minDiff = diff; candidates = [fof]; }
            else if (diff === minDiff) candidates.push(fof);
          });
        } else if (recommendationAlgo === 'community') {
          let maxMutual = -1;
          friendsOfFriends.forEach(fof => {
            const mutualCount = getMutualFriends(agent.id, fof.id, adj).length;
            if(mutualCount > maxMutual){ maxMutual = mutualCount; candidates = [fof]; }
            else if (mutualCount === maxMutual) candidates.push(fof);
          });
        }
        if(candidates.length > 0) {
          recommendedAgent = candidates[Math.floor(Math.random() * candidates.length)];
        }
      } else {
        const nonNeighbors = nodes.filter(n => !neighbors.has(n.id));
        if (nonNeighbors.length > 0) recommendedAgent = nonNeighbors[Math.floor(Math.random() * nonNeighbors.length)];
      }

      if (recommendedAgent) {
        let acceptProb;
        if (agent.isZealot) acceptProb = 1.0;
        else {
          const degree = (adj[agent.id] || []).length;
          const opinionDiff = Math.abs(agent.opinion - recommendedAgent.opinion);
          const homophilyFactor = 1 - opinionDiff;
          const degreeDecay = 25 / (25 + degree);
          acceptProb = homophilyFactor * degreeDecay;
        }
        if (Math.random() < acceptProb) {
          if (!linkExists(agent.id, recommendedAgent.id)) newLinks.push({ source: agent.id, target: recommendedAgent.id });
        }
      }
    });
    links.push(...newLinks);

    // Opinion update (weighted by zealots)
    const nextOpinions = new Map();
    const currentAdj = getAdjacencyList();
    nodes.forEach(agent => {
      if (agent.isZealot) { nextOpinions.set(agent.id, agent.opinion); return; }
      const neighborIds = currentAdj[agent.id] || [];
      if (neighborIds.length === 0) nextOpinions.set(agent.id, agent.opinion);
      else {
        let weightedSumOfOpinions = 0, sumOfWeights = 0;
        neighborIds.forEach(nid => {
          const neighbor = nodes.find(n => n.id === nid);
          if (neighbor) {
            const weight = neighbor.isZealot ? getZealotWeight() : 1;
            weightedSumOfOpinions += neighbor.opinion * weight;
            sumOfWeights += weight;
          }
        });
        const weightedAvgNeighborOpinion = sumOfWeights > 0 ? weightedSumOfOpinions / sumOfWeights : 0;
        const newOpinion = 0.5 * agent.opinion + 0.5 * weightedAvgNeighborOpinion;
        nextOpinions.set(agent.id, Math.max(0, Math.min(1, newOpinion)));
      }
    });
    nodes.forEach(agent => agent.opinion = nextOpinions.get(agent.id));

    // Unfriend farthest, random rewiring
    const linksToRemove = new Set();
    nodes.forEach(agent => {
      if (agent.isZealot) return;
      const currentNeighbors = (currentAdj[agent.id] || []).map(nid => nodes.find(n => n.id === nid)).filter(Boolean);
      if (currentNeighbors.length > 0) {
        let mostDistantFriend = null, maxDist = -1;
        currentNeighbors.forEach(neighbor => {
          const dist = Math.abs(agent.opinion - neighbor.opinion);
          if (dist > maxDist) { maxDist = dist; mostDistantFriend = neighbor; }
        });
        if (mostDistantFriend) {
          const unfriendProb = maxDist;
          if (Math.random() < unfriendProb) {
            const linkIndex = links.findIndex(l => {
              const sId = l.source.id ?? l.source; const tId = l.target.id ?? l.target;
              return (sId === agent.id && tId === mostDistantFriend.id) || (sId === mostDistantFriend.id && tId === agent.id);
            });
            if (linkIndex !== -1) linksToRemove.add(linkIndex);
          }
        }
      }
    });
    if (linksToRemove.size > 0) links = links.filter((_, i) => !linksToRemove.has(i));

    const finalAdj = getAdjacencyList();
    const rewiringLinksToAdd = [];
    const rewiringLinksToRemove = new Set();
    nodes.forEach(agent => {
      if (Math.random() < 0.05) {
        const agentNeighbors = finalAdj[agent.id] || [];
        if (agentNeighbors.length > 0) {
          const neighborToDropId = agentNeighbors[Math.floor(Math.random() * agentNeighbors.length)];
          const linkIndex = links.findIndex(l => {
            const sId = l.source.id ?? l.source; const tId = l.target.id ?? l.target;
            return (sId === agent.id && tId === neighborToDropId) || (sId === neighborToDropId && tId === agent.id);
          });
          if(linkIndex !== -1) rewiringLinksToRemove.add(linkIndex);

          const neighborSet = new Set(agentNeighbors);
          neighborSet.add(agent.id);
          const nonNeighbors = nodes.filter(n => !neighborSet.has(n.id));
          if (nonNeighbors.length > 0) {
            const newFriend = nonNeighbors[Math.floor(Math.random() * nonNeighbors.length)];
            rewiringLinksToAdd.push({ source: agent.id, target: newFriend.id });
          }
        }
      }
    });
    if (rewiringLinksToRemove.size > 0) links = links.filter((_, i) => !rewiringLinksToRemove.has(i));
    links.push(...rewiringLinksToAdd);

    // Metrics + redraw
    calculateAndDisplayMetrics();
    updateDisplays();
    updateSimulation();
    drawHeatmap();
  }

  function findClosestAgent(agent, candidates) {
    return candidates.reduce((closest, cand) => {
      const diff = Math.abs(agent.opinion - cand.opinion);
      return diff < Math.abs(agent.opinion - closest.opinion) ? cand : closest;
    }, candidates[0]);
  }

  // ===== Metrics =====
  function calculateAndDisplayMetrics() {
    if (nodes.length < 3 || links.length === 0) return;
    const opinions = nodes.map(n => n.opinion);
    const n = opinions.length;

    if (n > 1) {
      const mean = jStat.mean(opinions);
      const m2 = opinions.reduce((s,x)=>s+Math.pow(x-mean,2),0)/n;
      if (m2 > 0) {
        const m3 = opinions.reduce((s,x)=>s+Math.pow(x-mean,3),0)/n;
        const m4 = opinions.reduce((s,x)=>s+Math.pow(x-mean,4),0)/n;
        const g  = m3 / Math.pow(m2, 1.5);
        const k  = m4 / (m2*m2) - 3;
        const bc = (g*g + 1) / (k + 3);
        updateMetric('bc', bc);
      } else updateMetric('bc', 0);
    } else updateMetric('bc', 0);

    const { modularity } = calculateModularity(nodes, links);
    updateMetric('mod', modularity);

    const assortativity = calculateAssortativity(nodes, links);
    updateMetric('assort', assortativity);

    // APD
    if (n > 1) {
      let sumDiff = 0, cnt = 0;
      for (let i = 0; i < n; i++) {
        for (let j = i+1; j < n; j++) { sumDiff += Math.abs(opinions[i] - opinions[j]); cnt++; }
      }
      const apdVal = (cnt > 0) ? (2*sumDiff)/(n*(n-1)) : 0;
      updateMetric('apd', apdVal);
    } else { updateMetric('apd', 0); }
  }

  function calculateModularity(nodes, links) {
    const nodeIds = nodes.map(n => n.id.toString());
    const edgeList = links.map(l => ({ source: (l.source.id ?? l.source).toString(), target: (l.target.id ?? l.target).toString(), weight: 1 }));
    if (nodeIds.length === 0 || edgeList.length === 0) return { community: {}, modularity: 0 };

    let community = {}; nodeIds.forEach(id => community[id] = id);
    let m = edgeList.length, adj = {};
    edgeList.forEach(edge => { if (!adj[edge.source]) adj[edge.source] = {}; if (!adj[edge.target]) adj[edge.target] = {}; adj[edge.source][edge.target] = 1; adj[edge.target][edge.source] = 1; });
    let degrees = {}; nodeIds.forEach(id => { degrees[id] = 0; for(let nb in adj[id] || {}) degrees[id] += adj[id][nb]; });

    let improvement = true, iterations = 0;
    while(improvement && iterations < 10) {
      improvement = false; iterations++;
      nodeIds.forEach(nodeId => {
        let best_comm = community[nodeId], max_mod_gain = 0, neighbor_comms = new Set();
        if(adj[nodeId]) for(let nb in adj[nodeId]) neighbor_comms.add(community[nb]);
        neighbor_comms.forEach(comm_id => {
          let k_i_in = 0; if(adj[nodeId]) for(let nb in adj[nodeId]) if(community[nb] === comm_id) k_i_in += 1;
          let sigma_tot = 0; nodeIds.forEach(id => { if(community[id] === comm_id) sigma_tot += degrees[id]; });
          let mod_gain = k_i_in - (degrees[nodeId] * sigma_tot) / (2*m);
          if(mod_gain > max_mod_gain) { max_mod_gain = mod_gain; best_comm = comm_id; }
        });
        if(best_comm !== community[nodeId]) { community[nodeId] = best_comm; improvement = true; }
      });
    }

    let Q = 0, final_comms = {};
    Object.entries(community).forEach(([nodeId, commId]) => { if(!final_comms[commId]) final_comms[commId] = []; final_comms[commId].push(nodeId); });
    for(let commId in final_comms) {
      let l_c = 0, d_c = 0;
      final_comms[commId].forEach(node1 => {
        d_c += degrees[node1] || 0;
        final_comms[commId].forEach(node2 => { if(adj[node1] && adj[node1][node2]) l_c += 1; });
      });
      l_c /= 2;
      Q += (l_c / m) - Math.pow(d_c / (2*m), 2);
    }
    return { community, modularity: Q };
  }

  function calculateAssortativity(nodes, links) {
    if (links.length < 2) return 0;
    const m = links.length;
    const nodeMap = new Map(nodes.map(node => [node.id, node]));
    let sum1 = 0, sum2 = 0, sum3 = 0;
    links.forEach(link => {
      const sourceNode = nodeMap.get(link.source.id ?? link.source);
      const targetNode = nodeMap.get(link.target.id ?? link.target);
      if (!sourceNode || !targetNode) return;
      const w_i = sourceNode.opinion, w_j = targetNode.opinion;
      sum1 += w_i * w_j; sum2 += w_i + w_j; sum3 += w_i * w_i + w_j * w_j;
    });
    sum1 /= m; sum2 /= (2*m); sum3 /= (2*m);
    const numerator = sum1 - sum2 * sum2;
    const denominator = sum3 - sum2 * sum2;
    if (Math.abs(denominator) < 1e-10) return 0;
    return numerator / denominator;
  }

  // ===== Rendering =====
  let link = linkGroup.selectAll('line');
  let node = nodeGroup.selectAll('circle');

  function updateSimulation() {
    assignPositions();

    // Bind
    node = nodeGroup.selectAll('circle').data(nodes, d => d.id);
    link = linkGroup.selectAll('line').data(links, d => `${d.source.id ?? d.source}-${d.target.id ?? d.target}`);

    // EXIT
    node.exit().remove();
    link.exit().remove();

    // ENTER
    const nodeEnter = node.enter().append('circle')
      .attr('r', 6).attr('stroke', '#fff').attr('stroke-width', 1.5)
      .attr('cx', d => d.x).attr('cy', d => d.y)
      .attr('fill', d => colorScale(d.opinion))
      .on('mousemove', (event, d) => {
        const adj = getAdjacencyList();
        const degree = (adj[d.id] || []).length;
        tooltip.style('opacity', 0.95)
          .html(`ID: ${d.id}<br/>Opinion: ${d.opinion.toFixed(3)}<br/>Degree: ${degree}${d.isZealot ? '<br/><b>ZEALOT</b>' : ''}`)
          .style('left', (event.pageX + 10) + 'px')
          .style('top', (event.pageY - 28) + 'px');
      })
      .on('mouseleave', () => tooltip.style('opacity', 0));

    node = nodeEnter.merge(node);

    // Link ENTER+UPDATE
    const nodeById = new Map(nodes.map(n => [n.id, n]));
    link = link.enter().append('line')
      .attr('stroke', '#999').attr('stroke-opacity', 0.6)
      .merge(link);

    // UPDATE positions + colors
    link
      .attr('x1', d => (nodeById.get(d.source.id ?? d.source) || {}).x)
      .attr('y1', d => (nodeById.get(d.source.id ?? d.source) || {}).y)
      .attr('x2', d => (nodeById.get(d.target.id ?? d.target) || {}).x)
      .attr('y2', d => (nodeById.get(d.target.id ?? d.target) || {}).y);

    node
      .attr('cx', d => d.x)
      .attr('cy', d => d.y)
      .attr('fill', d => colorScale(d.opinion));
  }

  // ===== UI wiring =====
  document.getElementById('growth-rate').addEventListener('input', e => document.getElementById('growth-rate-value').textContent = parseFloat(e.target.value).toFixed(2));
  document.getElementById('growth-duration').addEventListener('input', e => document.getElementById('growth-duration-value').textContent = e.target.value);
  document.getElementById('zealot-weight').addEventListener('input', e => document.getElementById('zealot-weight-value').textContent = parseFloat(e.target.value).toFixed(1));

  document.getElementById('model-details-btn').addEventListener('click', () => {
    const content = document.getElementById('model-details-content');
    const arrow = document.getElementById('model-details-arrow');
    content.classList.toggle('active');
    arrow.textContent = content.classList.contains('active') ? '‚ñ≤' : '‚ñº';
  });


  const startPauseBtn = document.getElementById('start-pause-btn');
  startPauseBtn.addEventListener('click', () => {
    isRunning = !isRunning;
    if (isRunning) { startPauseBtn.textContent = 'Pause'; simulationInterval = setInterval(simulationStep, 500); }
    else { startPauseBtn.textContent = 'Start'; clearInterval(simulationInterval); }
  });
  document.getElementById('reset-btn').addEventListener('click', () => {
    isRunning = false; clearInterval(simulationInterval); startPauseBtn.textContent = 'Start'; initializeModel();
  });

  function updateDisplays() {
    d3.select('#time-step').text(timeStep);
    d3.select('#agent-count').text(nodes.length);
    d3.select('#zealot-count').text(nodes.filter(n => n.isZealot).length);
  }
  function updateMetric(key, value) {
    if (!isFinite(value)) value = 0;
    d3.select(`#${key}-value`).text(value.toFixed(3));
    const chart = charts[key];
    if (chart.data.labels.length > 100) { chart.data.labels.shift(); chart.data.datasets[0].data.shift(); }
    chart.data.labels.push(timeStep);
    chart.data.datasets[0].data.push(value);
    chart.update('none');
  }

  // ===== Heatmap =====
  const HM_BIN = 0.05;
  const HM_N = Math.floor(1 / HM_BIN);
  const HM_MARGIN = {top: 24, right: 24, bottom: 36, left: 40};
  const heatPanel = d3.select('#heatmap-panel');
  const hmSvg = d3.select('#heatmap-svg');
  let hmInited = false, hmG, hmX, hmY, hmInnerW, hmInnerH;

  function initHeatmapOnce(){
    if (hmInited) return;
    hmInited = true;
    heatPanel.classed('hidden', false);
    const w = hmSvg.node().getBoundingClientRect().width;
    const h = 420;
    hmSvg.attr('viewBox', `0 0 ${w} ${h}`);
    hmInnerW = w - HM_MARGIN.left - HM_MARGIN.right;
    hmInnerH = h - HM_MARGIN.top - HM_MARGIN.bottom;
    hmG = hmSvg.append('g').attr('transform', `translate(${HM_MARGIN.left},${HM_MARGIN.top})`);

    hmX = d3.scaleLinear().domain([0,1]).range([0, hmInnerW]);
    hmY = d3.scaleLinear().domain([0,1]).range([hmInnerH, 0]);

    const xAxis = d3.axisBottom(hmX).tickValues([0,0.5,1]).tickFormat(d3.format('.1f'));
    const yAxis = d3.axisLeft(hmY).tickValues([0,0.5,1]).tickFormat(d3.format('.1f'));
    hmG.append('g').attr('transform', `translate(0,${hmInnerH})`).call(xAxis);
    hmG.append('g').call(yAxis);
    hmG.append('text').attr('x', hmInnerW/2).attr('y', hmInnerH+28).attr('text-anchor','middle').attr('class','text-xs').text('Opinion (x)');
    hmG.append('text').attr('transform','rotate(-90)').attr('x',-hmInnerH/2).attr('y',-28).attr('text-anchor','middle').attr('class','text-xs').text('Opinion (y)');
  }

  function computeHeatCounts(){
    const counts = Array.from({length: HM_N}, ()=>Array(HM_N).fill(0));
    if (links.length === 0) return {counts, total: 0};

    const getBin = (w) => {
      let b = Math.floor(w / HM_BIN);
      if (b < 0) b = 0; if (b >= HM_N) b = HM_N - 1;
      return b;
    };
    const nodeMap = new Map(nodes.map(n => [n.id, n]));
    links.forEach(l => {
      const s = nodeMap.get(l.source.id ?? l.source);
      const t = nodeMap.get(l.target.id ?? l.target);
      if (!s || !t) return;
      const bi = getBin(s.opinion);
      const bj = getBin(t.opinion);
      counts[bi][bj] += 1; // directed density; remove symmetry on purpose
    });
    return {counts, total: links.length};
  }

  function drawHeatmap(){
    initHeatmapOnce();
    const {counts, total} = computeHeatCounts();
    const cellW = hmInnerW / HM_N, cellH = hmInnerH / HM_N;

    const data = [];
    for(let i=0;i<HM_N;i++){
      for(let j=0;j<HM_N;j++){
        const frac = total>0 ? counts[i][j] / total : 0;
        data.push({i,j,frac});
      }
    }
    function colorFor(frac){
      if (frac <= 0) return '#e5e7eb';      // light gray for empty
      const t = Math.max(0, Math.min(1, frac));
      return d3.interpolateReds(0.15 + 0.85*t);  // light red -> deep red
    }
    const cells = hmG.selectAll('rect.hm').data(data, d => `${d.i}-${d.j}`);
    cells.enter().append('rect')
      .attr('class','hm').attr('x', d => hmX(d.i*HM_BIN))
      .attr('y', d => hmY((d.j+1)*HM_BIN)).attr('width', cellW).attr('height', cellH)
      .attr('stroke','#fff').attr('stroke-width',0.5)
      .merge(cells)
      .attr('fill', d => colorFor(d.frac));
    cells.exit().remove();

    hmG.selectAll('rect.hm')
      .on('mousemove', (event, d) => {
        const x0=(d.i*HM_BIN).toFixed(1), x1=((d.i+1)*HM_BIN).toFixed(1);
        const y0=(d.j*HM_BIN).toFixed(1), y1=((d.j+1)*HM_BIN).toFixed(1);
        const pct=(d.frac*100).toFixed(2)+'%';
        tooltip.style('opacity', .95)
          .html(`Bin x: [${x0}, ${x1})<br/>Bin y: [${y0}, ${y1})<br/>Share of links: <b>${pct}</b>`)
          .style('left', (event.pageX + 10) + 'px')
          .style('top', (event.pageY - 28) + 'px');
      })
      .on('mouseleave', () => tooltip.style('opacity', 0));
  }

  // ===== Charts init & model start =====
  charts.bc = createChart('bc-chart', chartConfigs.bc);
  charts.mod = createChart('mod-chart', chartConfigs.mod);
  charts.assort = createChart('assort-chart', chartConfigs.assort);
  charts.apd = createChart('apd-chart', chartConfigs.apd);
  initializeModel();
</script>
</body>
</html>
