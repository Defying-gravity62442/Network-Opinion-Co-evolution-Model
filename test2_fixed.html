<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Network-Opinion Co-evolution Model</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jstat/1.9.6/jstat.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@2.2.1/dist/chartjs-plugin-annotation.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    body { font-family: 'Inter', sans-serif; overscroll-behavior: none; }
    .chart-container { position: relative; height: 90px; width: 100%; }
    .tooltip { position: absolute; text-align: center; padding: 8px; font: 12px sans-serif; background: lightsteelblue; border-radius: 8px; pointer-events: none; opacity: 0; transition: opacity 0.2s; }
  </style>
</head>
<body class="bg-gray-100 text-gray-800 antialiased">

<div class="container mx-auto p-4 max-w-7xl">
  <div class="text-center mb-4">
    <h1 class="text-3xl font-bold text-gray-900">Network-Opinion Co-evolution Model</h1>
    <p class="text-md text-gray-600 mb-2">An interactive simulation by Will Gao, Yash Meher, and Fred Pan.</p>
    <div class="text-sm text-gray-500 max-w-2xl mx-auto bg-gray-50 p-3 rounded-lg border">
      <strong>Abstract:</strong> We present a discrete-time, agent-based Markov model capturing the coupled dynamics of a social network's topology and the continuous opinions of its agents...
    </div>
  </div>

  <div class="flex flex-col lg:flex-row gap-4">
    <div class="w-full lg:w-1/3 bg-white p-4 rounded-lg shadow-md flex flex-col gap-4 overflow-y-auto max-h-[calc(100vh-2rem)]">
      <div>
        <h2 class="text-xl font-bold mb-3 border-b pb-2">Controls</h2>
        <div class="grid grid-cols-2 gap-2 mb-3">
          <button id="start-pause-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg">Start</button>
          <button id="reset-btn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg">Reset</button>
        </div>
        <div class="space-y-3">
          <div>
            <label class="block font-medium mb-1">Friend Recommendation:</label>
            <select id="recommendation-algo" class="w-full p-2 border rounded-lg bg-gray-50">
              <option value="homophily" selected>Homophily-based</option>
              <option value="random">Random FoF</option>
              <option value="popularity">Popularity-based</option>
              <option value="community">Community-based</option>
            </select>
          </div>
          <div>
            <label>Growth Rate (r): <span id="growth-rate-value" class="font-mono text-sm">0.10</span></label>
            <input type="range" id="growth-rate" min="0.01" max="0.30" step="0.01" value="0.10" class="w-full">
          </div>
          <div>
            <label>Growth Duration (T): <span id="growth-duration-value" class="font-mono text-sm">75</span></label>
            <input type="range" id="growth-duration" min="10" max="200" step="5" value="75" class="w-full">
          </div>
          <div>
            <label>Zealot Weight (W<sub>z</sub>): <span id="zealot-weight-value" class="font-mono text-sm">5.0</span></label>
            <input type="range" id="zealot-weight" min="1.0" max="20.0" step="0.5" value="5.0" class="w-full">
          </div>
        </div>
      </div>

      <div>
        <h2 class="text-xl font-bold mb-3 border-b pb-2">Live Statistics</h2>
        <div class="grid grid-cols-2 gap-2 text-center">
          <div class="bg-gray-100 p-2 rounded-lg">
            <div class="text-sm text-gray-500">Time Step (t)</div>
            <div id="time-step" class="text-2xl font-bold">0</div>
          </div>
          <div class="bg-gray-100 p-2 rounded-lg">
            <div class="text-sm text-gray-500">Agents</div>
            <div id="agent-count" class="text-2xl font-bold">0</div>
          </div>
        </div>
      </div>

      <div>
        <h2 class="text-xl font-bold mb-3 border-b pb-2">Polarization Metrics</h2>
        <div class="grid grid-cols-2 gap-4">
          <div>
            <h3 class="font-semibold">Bimodality Coefficient <span id="bc-value" class="font-mono text-sm bg-gray-200 px-1 rounded">0.000</span></h3>
            <div class="chart-container"><canvas id="bc-chart"></canvas></div>
          </div>
          <div>
            <h3 class="font-semibold">Network Modularity (Q) <span id="mod-value" class="font-mono text-sm bg-gray-200 px-1 rounded">0.000</span></h3>
            <div class="chart-container"><canvas id="mod-chart"></canvas></div>
          </div>
          <div>
            <h3 class="font-semibold">Opinion Assortativity (r) <span id="assort-value" class="font-mono text-sm bg-gray-200 px-1 rounded">0.000</span></h3>
            <div class="chart-container"><canvas id="assort-chart"></canvas></div>
          </div>
          <div>
            <h3 class="font-semibold">Esteban-Ray Index <span id="er-value" class="font-mono text-sm bg-gray-200 px-1 rounded">0.000</span></h3>
            <div class="chart-container"><canvas id="er-chart"></canvas></div>
          </div>
        </div>
      </div>
    </div>

    <div class="w-full lg:w-2/3 bg-white rounded-lg shadow-md overflow-hidden">
      <svg id="simulation-svg" class="w-full h-[calc(100vh-2rem)]"></svg>
    </div>
  </div>
</div>

<div id="tooltip" class="tooltip"></div>

<script type="module">
  const P_PAIRED_ZEALOT = 0.01;
  const P_REWIRE = 0.05;
  const INITIAL_AGENTS = 4;
  const CHARACTERISTIC_DEGREE = 25;
  const OPINION_INERTIA = 0.5;

  function getGrowthRate() { return parseFloat(document.getElementById('growth-rate').value); }
  function getGrowthDuration() { return parseInt(document.getElementById('growth-duration').value); }
  function getZealotWeight() { return parseFloat(document.getElementById('zealot-weight').value); }

  let nodes = [], links = [], timeStep = 0, isRunning = false, simulationInterval, nextNodeId = 0;

  const svg = d3.select("#simulation-svg");
  const zoomLayer = svg.append("g");
  const tooltip = d3.select("#tooltip");

  svg.call(d3.zoom().scaleExtent([0.1, 4]).on("zoom", (event) => {
    zoomLayer.attr("transform", event.transform);
  }));

  const linkGroup = zoomLayer.append("g").attr("class", "links");
  const nodeGroup = zoomLayer.append("g").attr("class", "nodes");

  const width = svg.node().getBoundingClientRect().width;
  const height = svg.node().getBoundingClientRect().height;
  const colorScale = d3.scaleSequential(d3.interpolateCool).domain([0, 1]);

  const simulation = d3.forceSimulation(nodes)
    .force("link", d3.forceLink(links).id(d => d.id).distance(50).strength(0.1))
    .force("charge", d3.forceManyBody().strength(-150))
    .force("center", d3.forceCenter(width / 2, height / 2))
    .on("tick", ticked);

  let link, node;

  const chartConfigs = {
    bc: { label: 'Bimodality Coefficient', data: [], line: 0.555 },
    mod: { label: 'Network Modularity (Q)', data: [] },
    assort: { label: 'Opinion Assortativity (r)', data: [] },
    er: { label: 'Esteban-Ray Index', data: [] }
  };
  const charts = {};
  Chart.register(window['chartjs-plugin-annotation']);
  function createChart(canvasId, config) {
    const ctx = document.getElementById(canvasId).getContext('2d');
    return new Chart(ctx, {
      type: 'line',
      data: { labels: [], datasets: [{ label: config.label, data: config.data, borderColor: 'rgba(59, 130, 246, 0.8)', backgroundColor: 'rgba(59, 130, 246, 0.1)', borderWidth: 2, pointRadius: 0, tension: 0.3, fill: true }] },
      options: {
        responsive: true, maintainAspectRatio: false,
        scales: { x: { display: false }, y: { suggestedMin: (canvasId === 'assort-chart') ? -1 : 0, suggestedMax: 1, ticks: { maxTicksLimit: 4 } } },
        plugins: { legend: { display: false }, annotation: config.line ? { annotations: { line1: { type: 'line', yMin: config.line, yMax: config.line, borderColor: 'red', borderWidth: 2, borderDash: [6, 6] } } } : {} }
      }
    });
  }

  function initializeModel() {
    timeStep = 0; nextNodeId = 0; nodes.length = 0; links.length = 0;
    for (let i = 0; i < INITIAL_AGENTS; i++) nodes.push(createAgent());
    for (let i = 0; i < INITIAL_AGENTS; i++) for (let j = i + 1; j < INITIAL_AGENTS; j++) links.push({ source: nodes[i].id, target: nodes[j].id });
    for (const key in charts) { charts[key].data.labels = []; charts[key].data.datasets[0].data = []; charts[key].update(); }
    updateDisplays(); updateSimulation();
  }
  function createAgent(isZealot = false, fixedOpinion = null) {
    const agent = { id: nextNodeId++, opinion: jStat.beta.sample(2, 2), isZealot: isZealot };
    if (isZealot) agent.opinion = (fixedOpinion !== null) ? fixedOpinion : (Math.random() < 0.5 ? 0 : 1);
    return agent;
  }
  function linkExists(a, b) { return links.some(l => { const s = l.source.id ?? l.source; const t = l.target.id ?? l.target; return (s === a && t === b) || (s === b && t === a); }); }

  function findClosestAgent(agent, candidates) {
    return candidates.reduce((closest, cand) => {
      const diff = Math.abs(agent.opinion - cand.opinion);
      return diff < Math.abs(agent.opinion - closest.opinion) ? cand : closest;
    }, candidates[0]);
  }

  function simulationStep() {
    if (nodes.length === 0) return;
    timeStep++;

    if (timeStep <= getGrowthDuration()) {
      const numNewAgents = Math.max(1, Math.floor(nodes.length * getGrowthRate()));
      const existingAgents = nodes.slice();
      const nonZealotTargets = existingAgents.filter(a => !a.isZealot);

      let agentsToAdd = 0;
      while (agentsToAdd < numNewAgents) {
        const isZealotArrival = Math.random() < 0.01;
        if (isZealotArrival && nonZealotTargets.length > 0) {
          const zealot1 = createAgent(true, 0);
          const zealot2 = createAgent(true, 1);
          let target1 = findClosestAgent(zealot1, nonZealotTargets);
          nodes.push(zealot1);
          if(target1 && !linkExists(zealot1.id, target1.id)) links.push({ source: zealot1.id, target: target1.id });
          let target2 = findClosestAgent(zealot2, nonZealotTargets);
          nodes.push(zealot2);
          if(target2 && !linkExists(zealot2.id, target2.id)) links.push({ source: zealot2.id, target: target2.id });
          agentsToAdd += 2;
        } else {
          const newcomer = createAgent(false);
          nodes.push(newcomer);
          if (existingAgents.length > 0) {
            const targetAgent = existingAgents[Math.floor(Math.random() * existingAgents.length)];
            if (!linkExists(newcomer.id, targetAgent.id)) links.push({ source: newcomer.id, target: targetAgent.id });
          }
          agentsToAdd++;
        }
      }
    }

    const recommendationAlgo = document.getElementById('recommendation-algo').value;
    const newLinks = [];
    const adj = getAdjacencyList();

    nodes.forEach(agent => {
      const neighbors = new Set(adj[agent.id] || []);
      neighbors.add(agent.id);

      let recommendedAgent = null;
      const friendsOfFriends = getFriendsOfFriends(agent.id, adj);

      if (friendsOfFriends.length > 0) {
        let candidates = [];
        if (recommendationAlgo === 'random') {
          candidates = friendsOfFriends;
        } else if (recommendationAlgo === 'popularity') {
          let maxDegree = -1;
          friendsOfFriends.forEach(fof => {
            const degree = (adj[fof.id] || []).length;
            if(degree > maxDegree) { maxDegree = degree; candidates = [fof]; }
            else if (degree === maxDegree) candidates.push(fof);
          });
        } else if (recommendationAlgo === 'homophily') {
          let minDiff = Infinity;
          friendsOfFriends.forEach(fof => {
            const diff = Math.abs(fof.opinion - agent.opinion);
            if(diff < minDiff){ minDiff = diff; candidates = [fof]; }
            else if (diff === minDiff) candidates.push(fof);
          });
        } else if (recommendationAlgo === 'community') {
          let maxMutual = -1;
          friendsOfFriends.forEach(fof => {
            const mutualCount = getMutualFriends(agent.id, fof.id, adj).length;
            if(mutualCount > maxMutual){ maxMutual = mutualCount; candidates = [fof]; }
            else if (mutualCount === maxMutual) candidates.push(fof);
          });
        }
        if(candidates.length > 0) {
          recommendedAgent = candidates[Math.floor(Math.random() * candidates.length)];
        }
      } else {
        const nonNeighbors = nodes.filter(n => !neighbors.has(n.id));
        if (nonNeighbors.length > 0) recommendedAgent = nonNeighbors[Math.floor(Math.random() * nonNeighbors.length)];
      }

      if (recommendedAgent) {
        let acceptProb;
        if (agent.isZealot) acceptProb = 1.0;
        else {
          const degree = (adj[agent.id] || []).length;
          const opinionDiff = Math.abs(agent.opinion - recommendedAgent.opinion);
          const homophilyFactor = 1 - opinionDiff;
          const degreeDecay = 25 / (25 + degree);
          acceptProb = homophilyFactor * degreeDecay;
        }
        if (Math.random() < acceptProb) {
          if (!linkExists(agent.id, recommendedAgent.id)) newLinks.push({ source: agent.id, target: recommendedAgent.id });
        }
      }
    });
    links.push(...newLinks);

    const nextOpinions = new Map();
    const currentAdj = getAdjacencyList();
    nodes.forEach(agent => {
      if (agent.isZealot) { nextOpinions.set(agent.id, agent.opinion); return; }
      const neighborIds = currentAdj[agent.id] || [];
      if (neighborIds.length === 0) nextOpinions.set(agent.id, agent.opinion);
      else {
        let weightedSumOfOpinions = 0, sumOfWeights = 0;
        neighborIds.forEach(nid => {
          const neighbor = nodes.find(n => n.id === nid);
          if (neighbor) {
            const weight = neighbor.isZealot ? getZealotWeight() : 1;
            weightedSumOfOpinions += neighbor.opinion * weight;
            sumOfWeights += weight;
          }
        });
        const weightedAvgNeighborOpinion = sumOfWeights > 0 ? weightedSumOfOpinions / sumOfWeights : 0;
        const newOpinion = 0.5 * agent.opinion + 0.5 * weightedAvgNeighborOpinion;
        nextOpinions.set(agent.id, Math.max(0, Math.min(1, newOpinion)));
      }
    });
    nodes.forEach(agent => agent.opinion = nextOpinions.get(agent.id));

    const linksToRemove = new Set();
    nodes.forEach(agent => {
      if (agent.isZealot) return;
      const currentNeighbors = (currentAdj[agent.id] || []).map(nid => nodes.find(n => n.id === nid)).filter(Boolean);
      if (currentNeighbors.length > 0) {
        let mostDistantFriend = null, maxDist = -1;
        currentNeighbors.forEach(neighbor => {
          const dist = Math.abs(agent.opinion - neighbor.opinion);
          if (dist > maxDist) { maxDist = dist; mostDistantFriend = neighbor; }
        });
        if (mostDistantFriend) {
          const unfriendProb = maxDist;
          if (Math.random() < unfriendProb) {
            const linkIndex = links.findIndex(l => {
              const sId = l.source.id ?? l.source; const tId = l.target.id ?? l.target;
              return (sId === agent.id && tId === mostDistantFriend.id) || (sId === mostDistantFriend.id && tId === agent.id);
            });
            if (linkIndex !== -1) linksToRemove.add(linkIndex);
          }
        }
      }
    });
    if (linksToRemove.size > 0) links = links.filter((_, i) => !linksToRemove.has(i));

    const finalAdj = getAdjacencyList();
    const rewiringLinksToAdd = [];
    const rewiringLinksToRemove = new Set();

    nodes.forEach(agent => {
      if (Math.random() < 0.05) {
        const agentNeighbors = finalAdj[agent.id] || [];
        if (agentNeighbors.length > 0) {
          const neighborToDropId = agentNeighbors[Math.floor(Math.random() * agentNeighbors.length)];
          const linkIndex = links.findIndex(l => {
            const sId = l.source.id ?? l.source; const tId = l.target.id ?? l.target;
            return (sId === agent.id && tId === neighborToDropId) || (sId === neighborToDropId && tId === agent.id);
          });
          if(linkIndex !== -1) rewiringLinksToRemove.add(linkIndex);

          const neighborSet = new Set(agentNeighbors);
          neighborSet.add(agent.id);
          const nonNeighbors = nodes.filter(n => !neighborSet.has(n.id));
          if (nonNeighbors.length > 0) {
            const newFriend = nonNeighbors[Math.floor(Math.random() * nonNeighbors.length)];
            rewiringLinksToAdd.push({ source: agent.id, target: newFriend.id });
          }
        }
      }
    });
    if (rewiringLinksToRemove.size > 0) links = links.filter((_, i) => !rewiringLinksToRemove.has(i));
    links.push(...rewiringLinksToAdd);

    calculateAndDisplayMetrics();
    updateDisplays();
    updateSimulation();
  }

  function calculateAndDisplayMetrics() {
    if (nodes.length < 3 || links.length === 0) return;
    const opinions = nodes.map(n => n.opinion);
    const n = opinions.length;

    // BC per Metrics doc
    if (n > 1) {
      const mean = jStat.mean(opinions);
      const m2 = opinions.reduce((s,x)=>s+Math.pow(x-mean,2),0)/n;
      if (m2 > 0) {
        const m3 = opinions.reduce((s,x)=>s+Math.pow(x-mean,3),0)/n;
        const m4 = opinions.reduce((s,x)=>s+Math.pow(x-mean,4),0)/n;
        const g  = m3 / Math.pow(m2, 1.5);
        const k  = m4 / (m2*m2) - 3;
        const bc = (g*g + 1) / (k + 3);
        updateMetric('bc', bc);
      } else updateMetric('bc', 0);
    } else updateMetric('bc', 0);

    const { modularity } = calculateModularity(nodes, links);
    updateMetric('mod', modularity);

    const assortativity = calculateAssortativity(nodes, links);
    updateMetric('assort', assortativity);

    // ER* per Metrics doc Eq.(4)
    const { S1, S2, c1, c2 } = kmeans2Opinions(opinions);
    if (S1.length > 0 && S2.length > 0) {
      const p1 = S1.length / n, p2 = S2.length / n;
      const w1 = c1, w2 = c2;
      const alpha = 1.0;
      const sep = Math.abs(w1 - w2);
      const ERraw = Math.pow(p1, 1+alpha) * p2 * sep + Math.pow(p2, 1+alpha) * p1 * sep;
      const ERmax = Math.pow(p1, 1+alpha) * p2 + Math.pow(p2, 1+alpha) * p1;
      const ERstar = (ERmax > 0) ? (ERraw / ERmax) : 0;
      updateMetric('er', ERstar);
    } else {
      updateMetric('er', 0);
    }
  }

  function kmeans2Opinions(vals, iters=25) {
    if (vals.length === 0) return {S1:[], S2:[], c1:0, c2:0};
    const sorted = [...vals].sort((a,b)=>a-b);
    let c1 = sorted[Math.floor(sorted.length*0.25)];
    let c2 = sorted[Math.floor(sorted.length*0.75)];
    let S1 = [], S2 = [];
    for (let it=0; it<iters; it++) {
      S1.length=0; S2.length=0;
      for (const w of vals) (Math.abs(w-c1) <= Math.abs(w-c2) ? S1 : S2).push(w);
      const m1 = S1.length ? d3.mean(S1) : c1;
      const m2 = S2.length ? d3.mean(S2) : c2;
      if (Math.abs(m1-c1)+Math.abs(m2-c2) < 1e-9) break;
      c1 = m1; c2 = m2;
    }
    return {S1, S2, c1, c2};
  }

  function getAdjacencyList() {
    const adj = {};
    links.forEach(link => {
      const sourceId = link.source.id ?? link.source;
      const targetId = link.target.id ?? link.target;
      if (!adj[sourceId]) adj[sourceId] = [];
      if (!adj[targetId]) adj[targetId] = [];
      adj[sourceId].push(targetId);
      adj[targetId].push(sourceId);
    });
    return adj;
  }
  function getFriendsOfFriends(agentId, adj) {
    const friends = new Set(adj[agentId] || []);
    const fofs = new Set();
    friends.forEach(friendId => {
      (adj[friendId] || []).forEach(fofId => {
        if (fofId !== agentId && !friends.has(fofId)) fofs.add(fofId);
      });
    });
    return Array.from(fofs).map(id => nodes.find(n => n.id === id)).filter(Boolean);
  }
  function getMutualFriends(agent1Id, agent2Id, adj) {
    const friends1 = new Set(adj[agent1Id] || []);
    const friends2 = new Set(adj[agent2Id] || []);
    return [...friends1].filter(id => friends2.has(id));
  }
  function calculateModularity(nodes, links) {
    const nodeIds = nodes.map(n => n.id.toString());
    const edgeList = links.map(l => ({
      source: (l.source.id ?? l.source).toString(),
      target: (l.target.id ?? l.target).toString(),
      weight: 1
    }));
    if (nodeIds.length === 0 || edgeList.length === 0) return { community: {}, modularity: 0 };

    let community = {}; nodeIds.forEach(id => community[id] = id);
    let m = edgeList.length, adj = {};
    edgeList.forEach(edge => {
      if (!adj[edge.source]) adj[edge.source] = {};
      if (!adj[edge.target]) adj[edge.target] = {};
      adj[edge.source][edge.target] = 1; adj[edge.target][edge.source] = 1;
    });
    let degrees = {}; nodeIds.forEach(id => { degrees[id] = 0; for(let nb in adj[id] || {}) degrees[id] += adj[id][nb]; });

    let improvement = true, iterations = 0;
    while(improvement && iterations < 10) {
      improvement = false; iterations++;
      nodeIds.forEach(nodeId => {
        let best_comm = community[nodeId], max_mod_gain = 0, neighbor_comms = new Set();
        if(adj[nodeId]) for(let nb in adj[nodeId]) neighbor_comms.add(community[nb]);
        neighbor_comms.forEach(comm_id => {
          let k_i_in = 0; if(adj[nodeId]) for(let nb in adj[nodeId]) if(community[nb] === comm_id) k_i_in += 1;
          let sigma_tot = 0; nodeIds.forEach(id => { if(community[id] === comm_id) sigma_tot += degrees[id]; });
          let mod_gain = k_i_in - (degrees[nodeId] * sigma_tot) / (2*m);
          if(mod_gain > max_mod_gain) { max_mod_gain = mod_gain; best_comm = comm_id; }
        });
        if(best_comm !== community[nodeId]) { community[nodeId] = best_comm; improvement = true; }
      });
    }

    let Q = 0, final_comms = {};
    Object.entries(community).forEach(([nodeId, commId]) => { if(!final_comms[commId]) final_comms[commId] = []; final_comms[commId].push(nodeId); });
    for(let commId in final_comms) {
      let l_c = 0, d_c = 0;
      final_comms[commId].forEach(node1 => {
        d_c += degrees[node1] || 0;
        final_comms[commId].forEach(node2 => { if(adj[node1] && adj[node1][node2]) l_c += 1; });
      });
      l_c /= 2;
      Q += (l_c / m) - Math.pow(d_c / (2*m), 2);
    }
    return { community, modularity: Q };
  }
  function calculateAssortativity(nodes, links) {
    if (links.length < 2) return 0;
    const m = links.length;
    const nodeMap = new Map(nodes.map(node => [node.id, node]));
    let sum1 = 0, sum2 = 0, sum3 = 0;
    links.forEach(link => {
      const sourceNode = nodeMap.get(link.source.id ?? link.source);
      const targetNode = nodeMap.get(link.target.id ?? link.target);
      if (!sourceNode || !targetNode) return;
      const w_i = sourceNode.opinion, w_j = targetNode.opinion;
      sum1 += w_i * w_j; sum2 += w_i + w_j; sum3 += w_i * w_i + w_j * w_j;
    });
    sum1 /= m; sum2 /= (2*m); sum3 /= (2*m);
    const numerator = sum1 - sum2 * sum2;
    const denominator = sum3 - sum2 * sum2;
    if (Math.abs(denominator) < 1e-10) return 0;
    return numerator / denominator;
  }

  function updateDisplays() {
    d3.select("#time-step").text(timeStep);
    d3.select("#agent-count").text(nodes.length);
  }
  function updateMetric(key, value) {
    if (!isFinite(value)) value = 0;
    d3.select(`#${key}-value`).text(value.toFixed(3));
    const chart = charts[key];
    if (chart.data.labels.length > 100) { chart.data.labels.shift(); chart.data.datasets[0].data.shift(); }
    chart.data.labels.push(timeStep);
    chart.data.datasets[0].data.push(value);
    chart.update('none');
  }
  function updateSimulation() {
    node = nodeGroup.selectAll("circle").data(nodes, d => d.id);
    link = linkGroup.selectAll("line").data(links, d => `${d.source.id ?? d.source}-${d.target.id ?? d.target}`);
    node.exit().remove(); link.exit().remove();
    const nodeEnter = node.enter().append("circle")
      .attr("r", 6).attr("stroke", "#fff").attr("stroke-width", 1.5)
      .call(d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended))
      .on("mouseover", (event, d) => { tooltip.transition().duration(200).style("opacity", .9); tooltip.html(`ID: ${d.id}<br/>Opinion: ${d.opinion.toFixed(3)}<br/>${d.isZealot ? '<b>ZEALOT</b>' : ''}`).style("left", (event.pageX + 5) + "px").style("top", (event.pageY - 28) + "px"); })
      .on("mouseout", () => tooltip.transition().duration(500).style("opacity", 0));
    node = nodeEnter.merge(node);
    node.transition().duration(300).attr("fill", d => colorScale(d.opinion));
    link = link.enter().append("line").attr("stroke", "#999").attr("stroke-opacity", 0.6).merge(link);
    simulation.nodes(nodes); simulation.force("link").links(links); simulation.alpha(0.1).restart();
  }
  function ticked() {
    link.attr("x1", d => d.source.x).attr("y1", d => d.source.y).attr("x2", d => d.target.x).attr("y2", d => d.target.y);
    node.attr("cx", d => d.x).attr("cy", d => d.y);
  }
  function dragstarted(event, d) { if (!event.active) simulation.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; }
  function dragged(event, d) { d.fx = event.x; d.fy = event.y; }
  function dragended(event, d) { if (!event.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; }

  document.getElementById('growth-rate').addEventListener('input', e => document.getElementById('growth-rate-value').textContent = parseFloat(e.target.value).toFixed(2));
  document.getElementById('growth-duration').addEventListener('input', e => document.getElementById('growth-duration-value').textContent = e.target.value);
  document.getElementById('zealot-weight').addEventListener('input', e => document.getElementById('zealot-weight-value').textContent = parseFloat(e.target.value).toFixed(1));

  const startPauseBtn = document.getElementById('start-pause-btn');
  startPauseBtn.addEventListener('click', () => {
    isRunning = !isRunning;
    if (isRunning) { startPauseBtn.textContent = 'Pause'; simulationInterval = setInterval(simulationStep, 500); }
    else { startPauseBtn.textContent = 'Start'; clearInterval(simulationInterval); }
  });
  document.getElementById('reset-btn').addEventListener('click', () => {
    isRunning = false; clearInterval(simulationInterval); startPauseBtn.textContent = 'Start'; initializeModel();
  });

  // Init charts & model
  charts.bc = createChart('bc-chart', chartConfigs.bc);
  charts.mod = createChart('mod-chart', chartConfigs.mod);
  charts.assort = createChart('assort-chart', chartConfigs.assort);
  charts.er = createChart('er-chart', chartConfigs.er);
  initializeModel();
</script>
</body>
</html>
